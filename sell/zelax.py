import psycopg2
import subprocess
import telnetlib 
import time      
from datetime import datetime, timedelta

#---------------------------------------ФУНКЦИИ--------------------------------------------------#

#------------------------------------Функция pingurl()--------------------------------------#            
# Функция pingurl(url, typeos) для выполнения команды ping.                                 #
# Принимает на вхох IP-адрес устройства (url) и тип операционной системы (typeos)           #
# 'w' (Windows) или 'l' (Linux).                                                            #
# Возвращает 1 - если ping удался, 0 - если ping не удался.                                 #
#-------------------------------------------------------------------------------------------#

def pingurl(url, typeos):
    if typeos == 'w':
        command = ['ping', '-n', '1', url]  # For Windows.
    elif typeos == 'l':
        command = ['ping', '-c', '1', url]  # For Linux.
    ping = subprocess.call(command)
    if ping == 1: # Если url на ping не отозвался.
        return 0 # ping не удался.
    elif ping == 0: # Если url на ping отозвался.        
        return 1 # ping удался.

#----------------------------------Конец функции--------------------------------#
  
#---------------------------------------Функция write_txt()-------------------------------------#
# Функция write_txt(failwrite, timewrite) для записи провальных действий(ошибок)                #
# в текстовый файл logmistakeszel.txt.                                                          #
# Принимает на вход строку (failwrite) с описанием провального действия(ошибки) и               #
# текущего времени (timewrite).                                                                 #
#-----------------------------------------------------------------------------------------------#      
    
def write_txt(failwrite, timewrite):
#################################################################################################
    with open('/home/zarya/project/ubntserver/sell/logmistakeszel.txt', 'a', encoding='utf-8') as f:
    #with open('logmistakeszel.txt', 'a', encoding='utf-8') as f:# Для тестировании на Windows.
#################################################################################################
        f.write(f'{timewrite}-->{failwrite}' + '\n') # '\n' - для перехода на новую строку.
      
#------------------------------------------Конец функции----------------------------------------#       

#------------------------------------Функция------------------------------------#            
# Функция shell() для перехода в оболочку shell.                                #
# Возвращает строку вида # router(shell):                                       #
#-------------------------------------------------------------------------------#

def shell():
    tn.write(b'shell\n') # Ввод команды shell.
    
    time.sleep(0.1) # Задержка времени.

    # Получение данных Telnet-сессии.
    text = tn.read_very_eager().decode('utf-8') 
    
    return text # Возвращает данные из Telnet-сессии.

#----------------------------------Конец функции--------------------------------#        

#------------------------------------Функция------------------------------------#            
# Функция showsysmins() для просмотра наполненности слотов модулями             #
# и определения их типа из оболочки shell.                                      #
# Возвращает строку с данными о наполненности слотов модулями и их тип.         #
#-------------------------------------------------------------------------------#

def showsysmins():
    tn.write(b'show system mims\n')
    
    time.sleep(0.1) # Задержка времени.
      
    # Получение данных Telnet-сессии.
    text = tn.read_very_eager().decode('utf-8')
    
    return text # Возвращает данные из Telnet-сессии.

#----------------------------------Конец функции--------------------------------#

#------------------------------------Функция------------------------------------#
# Функция для определения наличия модулей в слотах и их типа.                   #
# Возвращает список с информацией о наличии или отсутствии модулей в слотах     #
# их типа. Пример 1: [4, 0]. Эта запись означает, что в первом слоте установлен #
# модуль 4FXO, во втором слоте модуль отсутствует.                              #
# Пример 2: [2, 4]. Эта запись означает, что в первом слоте установлен модуль   #
# 2FXS/2FXO, во втором слоте установлен модуль 4FXO.                            #
# Принимает на вход: text - результат выполнения команды show system mims.      #
#-------------------------------------------------------------------------------#

def fmodulem(text):
    mods_id = []
    flag_type_mods = []
    # Определение наполненности первого слота.
    mod_id_one = text.find('Module 1')
    if mod_id_one != -1:
        mods_id.append((1, mod_id_one)) # Модуль в первый слот установлен.
    else:
        mods_id.append((0, 0)) # Модуль в первый слот не установлен.
    # Определение наполненности второго слота.
    mod_id_two = text.find('Module 2')
    if mod_id_two != -1:
        mods_id.append((1, mod_id_two)) # Модуль во второй слот установлен. 
    else:
        mods_id.append((0, 0)) # Модуль во второй слот не установлен.
    # Пример: mods_id = [(1, 155), (0, 0)]

    for mod_id in mods_id:
        if mod_id[0] == 1: 
            find_type_mod = text[mod_id[1]+13:mod_id[1]+22]
            if find_type_mod.find('4') != -1: # Модуль => IME-4xFXO (4FXO).
                flag_type_mods.append(4)
            elif find_type_mod.find('2') != -1: # Модуль => IME-2xFXS-2xFXO (2FXS, 2FXO).
                flag_type_mods.append(2)
        elif mod_id[0] == 0: # Модуль в слот не установлен.
            flag_type_mods.append(0) 
             
    return flag_type_mods

#----------------------------------Конец функции--------------------------------#

#------------------------------------Функция------------------------------------#            
# Функция to_bytes(line) для формирования байтовой строки.                      #
# Принимает на вход строку типа 'show controller fxo 1/0'.                      #
# Возвращает байтовую строку строку b'show controller fxo 1/0\n'.               #
#-------------------------------------------------------------------------------#

def to_bytes(line):
    return f'{line}\n'.encode('utf-8')

#----------------------------------Конец функции--------------------------------#

#------------------------------------Функция------------------------------------#            
# Функция scontroller(port) для просмотра текущего состояния порта.             #
# Принимает на вход переменную port с типом порта.                              #
# Тип порта записывается в таком формате - fxo 1/0.                             #
# Возвращает строку с данными о текущем состоянии порта.                        #
#-------------------------------------------------------------------------------#

def scontroller(port):
    line = f'show controller {port}'
    tn.write(to_bytes(line))
    
    time.sleep(0.1) # Задержка времени.
      
    # Получение данных Telnet-сессии.
    text = tn.read_very_eager().decode('utf-8')
    
    return text # Возвращает данные из Telnet-сессии.

#----------------------------------Конец функции--------------------------------#

#------------------------------------Функция------------------------------------#            
# Функция для формирования списка из четырёх элементов описывающих текущее      #
# состояние каждого порта в модуле состоящего из 4 портов FXO.                  # 
# Возвращает список из четырёх элементов.                                       #
# Здесь в теле функции вызывается другая функция.                               # 
#-------------------------------------------------------------------------------#

def allportsfxo(nummod):
    listports = []
    numport = 0
    for numport in range(4):
        listports.append(scontroller(f'fxo {nummod}/{numport}')) 
        time.sleep(0.1) # Задержка времени.
        numport += 1
    return listports
           
#----------------------------------Конец функции--------------------------------#
    
#------------------------------------Функция------------------------------------#            
# Функция для формирования списка из четырёх элементов описывающих текущее      #
# состояние каждого порта в модуле состоящего из 2 портов FXS и 2 поров FXO.    # 
# Возвращает список из четырёх элементов.                                       #
# Здесь в теле функции вызывается другая функция.                               #
#-------------------------------------------------------------------------------#

def allportsfxsfxo(nummod):
    listports = []
    numport = 0
    for numport in range(4):
        if numport >= 0 and numport < 2:
            listports.append(scontroller(f'fxs {nummod}/{numport}'))            
        elif numport >= 2 and numport < 4:
            listports.append(scontroller(f'fxo {nummod}/{numport}'))
        time.sleep(0.1) # Задержка времени.
        numport += 1
    return listports

#----------------------------------Конец функции--------------------------------#

#------------------------------------Функция------------------------------------#            
# Функция для просмотра состояния соединения портов fxs и fxo локальной станции #
# с портами удалённой станции. Принимает на вход строку с текущем состоянием    #
# порта. Находит в ней подстроку с информацией о соединении.                    #
# Возвращает строку с состоянием соединения.                                    #
#-------------------------------------------------------------------------------#

def connect(text):
    state_con_id = text.find('Signaling state is')
    state_con_all = text[state_con_id+19:state_con_id+26]
    state_con = state_con_all.split('.')[0]     
    return state_con

#----------------------------------Конец функции--------------------------------#

#------------------------------------Функция------------------------------------#            
# Функция showrun() для просмотра настроек модулей FXO/FXS.                     #
# Возвращает строку с данными о настройках модулей FXO/FXS.                     #
#-------------------------------------------------------------------------------#

def showrun():
    line = f'show run\n'
    tn.write(to_bytes(line))
    time.sleep(0.2) # Задержка времени.
      
    # Получение данных Telnet-сессии.
    text = tn.read_very_eager().decode('utf-8')
    return text

#----------------------------------Конец функции--------------------------------#

#------------------------------------Функция------------------------------------#            
# Функция remoteserver(text) для получения IP удалённого сервера.               #
# Принимает на вход строку с ответом на ввод команды show run.                  #
# Возвращает строку с IP удалённого сервера.                                    #
#-------------------------------------------------------------------------------#

def remoteserver(text):
    remote_server_id = text.find('remote-server')
    if remote_server_id != -1:
        remote_server = text[remote_server_id+14:remote_server_id+27].split('\r')[0]    
    return remote_server

#----------------------------------Конец функции--------------------------------#

#------------------------------------Функция------------------------------------#            
# Функция porttype(text, numport) для получения данных о настройке              #
# порта (АТС или ТЧ). Обрабатываются только порты FXO.                          #
# Принимает на вход строку с ответом на ввод команды show run и номер порта.    #
# Возвращает строку с данными (АТС или ТЧ).                                     #
# ЭТА ФУНКЦИЯ ПОКА НЕ ПРИМЕНЯЕТСЯ.                                              #
#-------------------------------------------------------------------------------#

def porttype(text, numport):
    fxo_id = text.find(f'fxo {numport}')
    if fxo_id != -1:
        ptype = text[fxo_id+8:fxo_id+17].split(' ')    
    return ptype

#----------------------------------Конец функции--------------------------------#

#------------------------------------Функция------------------------------------#            
# Функция для просмотра усиления портов по входу и выходу.                      #
# Принимает на вход строку с текущем состоянием порта. Находит в ней подстроку  #
# с информацией об усилении.                                                    #
# Возвращает строку с информацией об усилении.                                  #
#-------------------------------------------------------------------------------#

def gain(text):
    gain_portinput_id = text.find('Gain level input is')
    gain_portout_id = text.find('output is')
    gain_portinput_all = text[gain_portinput_id+20:gain_portinput_id+36] # 30
    gain_portout_all = text[gain_portout_id+10:gain_portout_id+28] # 22
    gain_portinput = gain_portinput_all.split(',')[0]
    gain_portout_point = gain_portout_all.split('\r')[0] # 4.0db. или 13.0db.
    gain_portout = gain_portout_point[:-1] # 4.0db или 13.0db (Убирает точку в конце).
    return f'Вход: {gain_portinput}, Выход: {gain_portout}'

#----------------------------------Конец функции--------------------------------#

#-------------------Функция для записи успешных действий в БД-------------------#
        
def success(ipzel, successwrite, timewrite):
    data = (ipzel, successwrite, timewrite)
    connection = psycopg2.connect(dbn)
    cursor = connection.cursor()
    cursor.execute('INSERT INTO ubajax_zelsuccess(ipzel, successwrite, timewrite)\
                    VALUES(%s,%s,%s)',data)
    connection.commit()
    cursor.close()
    connection.close()

#-------------------------------------Конец функции-----------------------------------#

#---------------------Функция для записи провальных действий в БД---------------------#
        
def fail(ipzel, failwrite, timewrite):
    data = (ipzel, failwrite, timewrite)
    connection = psycopg2.connect(dbn)
    cursor = connection.cursor()
    cursor.execute('INSERT INTO ubajax_zelfail(ipzel, failwrite, timewrite)\
                    VALUES(%s,%s,%s)',data)
    connection.commit()
    cursor.close()
    connection.close()

#------------------------------------Конец функции------------------------------------#

#---------------------------------------Функция---------------------------------------#            
# Функция exitshell() для выхода из оболочки shell.                                   #                                                           
#-------------------------------------------------------------------------------------#

def exitshell():
    tn.write(b'exit\n')

#-------------------------------------Конец функции-----------------------------------#

#---------------------------------------Функция---------------------------------------#            
# Функция connectdb() для записи данных о сосотоянии соединения портов в БД.          #                                                           
#-------------------------------------------------------------------------------------#    

def writedb(param, station, ipzel):
    data = (ipzel, s1p0, s1p1, s1p2, s1p3, s2p0, s2p1, s2p2, s2p3, timewrite)
    connection = psycopg2.connect(dbn)
    cursor = connection.cursor()
    dt = f'INSERT INTO ubajax_zelslot{param}{station}(ipzel, s1p0, s1p1,\
                    s1p2, s1p3, s2p0, s2p1, s2p2, s2p3, timewrite)\
                    VALUES(%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)'
    cursor.execute(dt,data)
    connection.commit()
    cursor.close()
    connection.close()

#-------------------------------------Конец функции-----------------------------------#

#---------------------------------------Функция---------------------------------------#            
# Функция zellist() для .                                                             #                                                           
#-------------------------------------------------------------------------------------#

def zellist(slot1, slot2):
    n = 0
    for port in slot1:
        globals()[f's1p{n}'] = port
        n += 1    
    n = 0
    for port in slot2:
        globals()[f's2p{n}'] = port
        n += 1 

#-------------------------------------Конец функции-----------------------------------#

#---------------------------------------Функция---------------------------------------#            
# Функция enru() для .                                                                #
# Состояние соединения:                                                               #
#         Idle – исходное состояние, контроллер не активен;                           #
#         Connect – соединение установлено;                                           #
#         Waiting – ожидание соединения;                                              #
#         Dialing – приём набираемого номера из линии;                                #
#         Ringing – выдаётся звонок;                                                  #
#         Dial – передача набора номера из порта в линию;                             #
#         Break – ожидание разрыва соединения.                                        #
#-------------------------------------------------------------------------------------#

def enru(conen):
    if conen == 'Idle':
        conru = 'Исходное состояние, контроллер не активен'
    elif conen == 'Connect':
        conru = 'Соединение установлено'
    elif conen == 'Waiting':
        conru = 'Ожидание соединения'
    elif conen == 'Dialing':
        conru = 'Приём набираемого номера из линии'
    elif conen == 'Ringing':
        conru = 'Выдаётся звонок'
    elif conen == 'Dial':
        conru = 'Передача набора номера из порта в линию'    
    elif conen == 'Break':
        conru = 'Ожидание разрыва соединения'
    else:
        conru = 'Ошибка определения статуса соединения'
    return conru

#-------------------------------------Конец функции-----------------------------------#
 
#-------------------------------------КОНЕЦ ФУНКЦИЙ-----------------------------------------#

#############################################################################################
#----------------------------НАЧАЛО ПРОГРАММЫ МОНИТОРИНГА ZELAX-----------------------------#
#############################################################################################
        
#-----------------------------------ДЛЯ ТЕСТИРОВАНИЯ БЕЗ БД---------------------------------#
#urls = ['10.1.23.110', '10.1.23.111', '10.1.23.112', '10.1.23.113', '10.1.23.114',
#        '10.1.23.115', '10.1.11.116', '10.1.11.120', '10.1.11.121', '10.1.65.166']
#-------------------------------------------------------------------------------------------#

timewrite = datetime.now()  # Получаем текущее время для записи в БД и txt некоторых действий до цикла.

try: # Попытка.
#############################################################################################################
    with open('/home/zarya/project/ubntserver/sell/config', 'r') as f: # Для сервера 10.1.7.155.
    #with open('config', 'r') as f: # Для тестировании на Windows.
#############################################################################################################
        dbn = f.read() # Присваиваем переменной dbn строку с данными для доступа к БД.
    #print(dbn) # Для тестирования.
    # В переменную sucfailwrite, записываем успешное действие - 
    # 'Авторизационные данные для доступа к БД получены.'
    successwrite = 'Авторизационные данные для доступа к БД получены.'
    success('ОБЩАЯ', successwrite, timewrite)
    # Посмотреть эти данные можно только в БД через программу pgAdmin4.
    # Вместо IP искать 'ОБЩАЯ'.
    #print(successwrite)
    successwrite = ''    
except Exception: # Исключение.
    # В переменную failwrite, записываем ошибку - 
    # 'Ошибка получения авторизационных данных для доступа к БД,
    # Проверьте данные в файле "config"'
    failwrite = 'Ошибка получения авторизационных данных для доступа к БД,\
                    проверьте данные в файле "config"'
    # Так как авторизационные данные для доступа к БД не получены, то записать ошибку в БД мы не можем.
    # Ошибку запишем только в текстовый файл.
    write_txt(failwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakeszel.txt.
    failwrite = '' # Обнуляем переменную.
    # Ошибка запишется в текстовый файл, но из-за ошибки получения авторизационных данных 
    # для доступа к БД программа на следующих шагах остановится из-за невозможности получения 
    # данных из БД. Но мы будем знать причину, прочитав ошибку в файле logmistakeszel.txt.
    
#----------------------------------------------------------------------------------------#
        
timewritestart = datetime.now()
flagupdate = 1

#----------------------------------------------------------------------------------------#

#############################################################################################
#-----------------------------НАЧАЛО ГЛАВНОГО ЦИКЛА ПРОГРАММЫ-------------------------------#
#############################################################################################

while True: # Начало бесконечного цикла.
            # Цикл в котором получаем из БД строку с IP-адресами участвующими в мониторинге.
            # Получаем из строки список IP-адресов для которых разрешен мониторинг.

    connection = psycopg2.connect(dbn) # Подключение к БД с авторизационными данными dbn.
    cursor = connection.cursor() # Получение курсора для выполнения операций с БД.
    # Получение строки с перечнем IP-адресов из БД с разрешонным мониторингом.
    # '10.1.23.110 10.1.23.111 10.1.23.112 10.1.23.113'
    try: # Попытка.
        cursor.execute('SELECT ip_str from ubajax_zelipstr') # Выполнение SQL-запроса.
        # Если urls_all = cursor.fetchone() получаем кортеж с первым (нулевым) элементом.
        # Результат: ('10.1.23.110 10.1.23.111 10.1.23.112 10.1.23.113',)
        urls_all = cursor.fetchone()[0] # Получение результата.
                                        # '10.1.23.110 10.1.23.111 10.1.23.112 10.1.23.113'
        #print(urls_all) # Для тестирования.
        # Получаем список IP-адресов с разрешенным мониторингом.
        urls = urls_all.split(' ')
        #print(urls) # Для тестирования.
        # В переменную sucfailwrite, записываем успешное действие - 
        # 'Список IP-адресов получен из БД.'
        successwrite = 'Список IP-адресов получен из БД.'
        success('Для всех', successwrite, timewrite) # Запись успеха в БД.
        # Посмотреть эти данные можно только в БД через программу pgAdmin4.
        # Вместо IP искать 'Для всех'.
        successwrite = '' # Обнуляем переменную.
    except Exception: # Исключение.
        # В переменную failwrite, записываем ошибку - 
        # 'Ошибка получения списка IP-адресов из БД.'
        failwrite = 'Ошибка получения списка IP-адресов из БД.'
        fail('Для всех', failwrite, timewrite) # Запись ошибки в БД.
        # Посмотреть эти данные можно только в БД через программу pgAdmin4.
        # Вместо IP искать 'Для всех'.
        write_txt(failwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakeszel.txt.
        failwrite = '' # Обнуляем переменную.
        continue # Выходим из главного цикла программы. Разбираемся с ошибкой.
                 # Ошибку можно посмотреть в БД или в txt.
    #print(f'Список IP-адресов из БД: {urls}') # Для тестирования.
    cursor.close() # Закрытие курсора.
    connection.close() # Закрытие соединения.

#############################################################################################
#--------НАЧАЛО ЦИКЛА ПРОГРАММЫ ОБРАБОТКИ ПОСЛЕДОВАТЕЛЬНО КАЖДОГО IP-АДРЕСА ИЗ СПИСКА-------#
#############################################################################################    
                
    for ipzel in urls: # Цикл для обработки одного адреса из списка IP-адресов.
        #print('*********************************************************')
        timewrite = datetime.now() # Получаем текущее время для каждого ipzel в цикле.
        # При старте программы flagupdate = 1, все данные считываются и записываются в БД. 
        # В конце главного цикла программы сравниваем timewrite с timewritestart,
        # если прошёл 1 час или более, timewritestart присваиваем текущее значение времени
        # timewritestart = timewrite и flagupdate = 1 , если прошло меньше часа
        # flagupdate = 0 и часть данных не получаем и не записываем в БД. 

#----------------------------------------------------------------------------------------#        
        
        #print(f'Local IP: {ipzel}') # Для тестирования.
        
#---------------------------------ПИНГУЕМ ЛОКАЛЬНЫЙ URL----------------------------------#
        
        pu = pingurl(ipzel, 'l') # Вызов функции для осуществления ping.
        if pu == 1:
            successwrite = f'IP: {ipzel} на PING отозвался'
            success(ipzel, successwrite, timewrite)
            #print(successwrite)
            successwrite = ''
        elif pu == 0:
            failwrite = f'IP: {ipzel} на PING не отозвался'
            fail(ipzel, failwrite, timewrite)
            #print(failwrite)
            write_txt(failwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakeszel.txt.
            failwrite = ''
            #continue # Пропускаем эту итерацию цикла и переходим к следующему IP. 
        
#----------------------------------------------------------------------------------------#

#------------------ПОЛУЧЕНИЕ IP-АДРЕСА УДАЛЁННОГО ZELAX ipzelrem ИЗ БД-------------------#

        connection = psycopg2.connect(dbn)
        cursor = connection.cursor()
        # Получение удалённого IP-адреса.
        try: # Попытка.
            cursor.execute('SELECT ipzelrem from ubajax_zelinfo WHERE ipzel=%s', (ipzel,))
            #ipzelrem = cursor.fetchone() # ('10.1.123.110',)
            ipzelrem = cursor.fetchone()[0] # '10.1.123.110'
            # В переменную sucfailwrite, записываем успешное действие - 
            # 'Удалённый IP-адрес получен из БД.'
            successwrite = f'IP-адрес удалённого Zelax ({ipzelrem}) получен из БД.'
            success(ipzel, successwrite, timewrite)
            #print(successwrite)
            successwrite = ''
        except Exception: # Исключение.
            # В переменную sucfailwrite, записываем ошибку - 
            # 'Ошибка получения удалённого IP-адреса из БД.'
            ipzelrem = ''
            failwrite = 'Ошибка получения IP-адреса удалённого Zelax из БД.'
            fail(ipzel, failwrite, timewrite)
            write_txt(failwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakeszel.txt.
            #print(failwrite)
            failwrite = ''
        cursor.close()
        connection.close()

#----------------------------------------------------------------------------------------#            

#-----------------------------ПИНГУЕМ УДАЛЁННЫЙ IP-АДРЕСОМ-------------------------------#
        if ipzelrem != '':
            purem = pingurl(ipzelrem, 'l') # Вызов функции для осуществления ping.
            if purem == 1:
                successwrite = f'IP: {ipzelrem} на PING отозвался'
                success(ipzelrem, successwrite, timewrite)
                #print(successwrite)
                successwrite = ''
            elif purem == 0:
                failwrite = f'IP: {ipzelrem} на PING не отозвался'
                fail(ipzelrem, failwrite, timewrite)
                #print(failwrite)
                write_txt(failwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakeszel.txt.
                failwrite = ''
                #continue # Пропускаем эту итерацию цикла и переходим к следующему IP. 
        else:
            purem = 0
#----------------------------------------------------------------------------------------#

#--------------------ЕСЛИ НЕ ПИНГУЕТСЯ ЛОКАЛЬНЫЙ И УДАЛЁННЫЙ ZELAX-----------------------#

        if pu == 0 and purem == 0:
                        
#---------ЗАНОСИМ ДАННЫЕ В БД (ПИНГИ И СТАТУС СОЕДИНЕНИЯ) ПО ЛОКАЛЬНОМУ IP-АДРЕСУ--------#
        
            data = (ipzel, False, 0, 0, timewrite)
            connection = psycopg2.connect(dbn)
            cursor = connection.cursor()
            cursor.execute('INSERT INTO ubajax_zelstatusconline(ipzel, statusline,  pu, purem, timewrite)\
                            VALUES(%s,%s,%s,%s,%s)',data)
            connection.commit()
            cursor.close()
            connection.close()       
            #print('ЗАПИСАНО В БД zelstatusconline') # Для тестирования.
            failwrite = f'IP: {ipzel} и IP: {ipzelrem} на PING не отозвался'
            fail(ipzel, failwrite, timewrite) # Запись ошибки в БД для локального IP.
            fail(ipzelrem, failwrite, timewrite) #  Запись ошибки в БД для удалённого IP.
            #print(failwrite)
            write_txt(failwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakeszel.txt.
            failwrite = ''
        
#----------------------------------------------------------------------------------------#

            continue # Пропускаем эту итерацию цикла и переходим к следующему IP из списка.

#----------------------------ЕСЛИ ПИНГ ЛОКАЛЬНОГО ZELAX УСПЕШЕН--------------------------#
#---------------------ОТКРЫВАЕМ ТЕЛНЕТ-СЕССИЮ С ЛОКАЛЬНЫМ IP-АДРЕСОМ---------------------#
#---------------------------ВВОДИМ ИМЯ ПОЛЬЗОВАТЕЛЯ И ПАРОЛЬ-----------------------------#
#--------------------------ПОЛУЧАЕМ ИМЯ ЛОКАЛЬНОГО УСТРОЙСТВА----------------------------#

        elif pu == 1:
            try:
                tn = telnetlib.Telnet(ipzel) # Окрытие Telnet-сессии.
            except Exception: # Исключение.
                failwrite = f'Ошибка Telnet-сессии для IP: {ipzel}'
                fail(ipzel, failwrite, timewrite)
                #print(failwrite)
                write_txt(failwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakeszel.txt.
                failwrite = ''
                # В случае ошибки мы не можем выходить из цикла так-как
                # лишимся возможности получить информацию из удалённого zelax.
                # Но если удалённый zelax не пингуется, то можно выходить из цикла.
                # Поэтому создаю условие.
                if purem == 0:
                    continue # Пропускаем эту итерацию цикла и переходим к следующему IP из списка.
                                   
            # ПРЕДУПРЕЖДЕНИЕ: Перед методом read_very_eager 
            # всегда надо ставить time.sleep(n).
            time.sleep(0.1) # Задержка времени.

            # Получение данных Telnet-сессии.
            text = tn.read_very_eager().decode('utf-8')
            #print(text) # router login:

            connection = psycopg2.connect(dbn)
            cursor = connection.cursor()
            # Получение логина и пароля для входа в Zelax для одного IP-адреса.
            # [('admin', 'admin')]
            cursor.execute('SELECT zellogin, zelpassword from ubajax_zelinfo WHERE ipzel=%s', (ipzel,))
            #logpas = cursor.fetchall() # [('admin', 'admin')] Логин и пароль в одном списке и кортеже.
            logpas = cursor.fetchone() # ('admin', 'admin') Логин и пароль в одном кортеже.
            #print(logpas) # Для тестирования.
            cursor.close()
            connection.close()
        
            if text.find('login:') != -1:
                successwrite = f'Успешное открытие Telnet-сессии для IP: {ipzel}'
                success(ipzel, successwrite, timewrite)
                #print(successwrite)
                successwrite = ''
                login = logpas[0] # Логин. Нулевой элемент списка, нулевой элемент кортежа.
                tn.write(to_bytes(login)) # Ввод логина (Логин: admin).
                #tn.write(b'admin\n') # Ввод логина (Логин: admin).
            else:
                failwrite = f'Ошибка доступа к устройству с IP: {ipzel}'
                fail(ipzel, failwrite, timewrite)
                #print(failwrite)
                write_txt(failwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakeszel.txt.
                failwrite = ''
                tn.close() # Закрытие Телнет-сессии.
                # В случае ошибки мы не можем выходить из цикла так-как
                # лишимся возможности получить информацию из удалённого zelax.
                # Но если удалённый zelax не пингуется, то можно выходить из цикла.
                # Поэтому создаю условие.
                if purem == 0:
                    continue # Пропускаем эту итерацию цикла и переходим к следующему IP из списка.
                
            time.sleep(0.1) # Задержка времени.
        
            # Получение данных Telnet-сессии.
            text = tn.read_very_eager().decode('utf-8')
            #print(text) # router Password:
            if text.find('Password:') != -1:
                password = logpas[1] # Пароль. Нулевой элемент списка, первый элемент кортежа.
                tn.write(to_bytes(password)) # Ввод пароля (Пароль: admin).
                #tn.write(b'admin\n') # Ввод пароля (Пароль: admin).
            else:
                failwrite = f'Ошибка доступа к устройству с IP: {ipzel}'
                fail(ipzel, failwrite, timewrite)
                #print(failwrite)
                write_txt(failwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakeszel.txt.
                failwrite = ''
                tn.close() # Закрытие Телнет-сессии.
                # В случае ошибки мы не можем выходить из цикла так-как
                # лишимся возможности получить информацию из удалённого zelax.
                # Но если удалённый zelax не пингуется, то можно выходить из цикла.
                # Поэтому создаю условие.
                if purem == 0:
                    continue # Пропускаем эту итерацию цикла и переходим к следующему IP из списка.
                
            time.sleep(0.5) # Задержка времени.
        
            # Получение данных Telnet-сессии.
            text = tn.read_very_eager().decode('utf-8')
            #print(text) # router#

            try:
                namezellocfrom = text[:-1].split('\n')[1] # Получения среза. 
                                                # От начала принятой строки до
                                                # предпоследнего элемента.                               
                # Вывод на печать имени устройства.
                #print('Имя устройства --> ', namezellocfrom)
                #print('---------------------------------------------------------')
            except Exception: # Исключение.
                failwrite = f'Ошибка авторизации для IP: {ipzel}'
                fail(ipzel, failwrite, timewrite)
                #print(failwrite)
                write_txt(failwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakeszel.txt.
                failwrite = ''
                # В случае ошибки мы не можем выходить из цикла так-как
                # лишимся возможности получить информацию из удалённого zelax.
                # Но если удалённый zelax не пингуется, то можно выходить из цикла.
                # Поэтому создаю условие.
                if purem == 0:
                    continue # Пропускаем эту итерацию цикла и переходим к следующему IP из списка.

#----------------------------------------------------------------------------------------#        

#---------------------------------ПЕРЕХОД В ОБОЛОЧКУ shell-------------------------------#
        
            text = shell()
            #print(text) Для тестирования.(router(shell):)

            if text.find('(shell)#') == -1:
                failwrite = f'Ошибка ввода команды Shell в IP: {ipzel}'
                fail(ipzel, failwrite, timewrite)
                #print(failwrite)
                write_txt(failwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakeszel.txt.
                failwrite = ''
                tn.write(b'reboot\n') # Перегружаем устройство.
                                      # Телнет сессия закрывается автоматически.

#---------------------------------------------------------------------------------------#

#--------------ВВОД КОМАНДЫ show system mims И ПОЛУЧЕНИЕ ТЕКСТА textmins----------------#

            textmins = showsysmins()

#---------------------------------------------------------------------------------------#

#-------------ПОЛУЧЕНИЕ ИЗ textmins наполненности слотов модулями и их тип--------------#
        
            modlist = fmodulem(textmins) # [4, 4] или [4, 2] или [4, 0]
        
#---------------------------------------------------------------------------------------#        

#----------------------ВВОД КОМАНДЫ show run И ПОЛУЧЕНИЕ ТЕКСТА ttext-------------------#
                        
            ttext = showrun() # Вызов функции showrun().
            #print(ttext) # Для тестирования.

#---------------------------------------------------------------------------------------#

#-----------------------ПОЛУЧЕНИЕ ИЗ ttext IP удалённого сервера------------------------#
            
            # Получаем IP-адрес удалённого zelax из БД, поэтому получать из устройсва
            # пока не актуально.
            #ipzelrem = remoteserver(ttext) # Вызов функции remoteserver().
            #print('IP удалённого сервера ->', ipzelrem)
                        
#---------------------------------------------------------------------------------------#
        
#---------------ОПРЕДЕЛЯЕМ УСТАНОВЛЕНО ЛИ СОЕДИНЕНИЕ С УДАЛЁННЫМ СЕРВЕРОМ---------------#
        
            tn.write(b'show voice-connections active\n')
        
            time.sleep(0.1) # Задержка времени.
        
            # Получение данных Telnet-сессии.
            text = tn.read_very_eager().decode('utf-8')
            #print(text) # Для тестирования.

            findcon = text.find('Connect')
            if findcon != -1:
                statusline = True
                successwrite = f'Соединение с удалённым сервером {ipzelrem} установлено'
                success(ipzel, successwrite, timewrite)
                #print(successwrite)
                successwrite = ''
            elif findcon == -1:
                statusline = False
                failwrite = f'Соединение с удалённым сервером {ipzelrem} не установлено'
                fail(ipzel, failwrite, timewrite)
                write_txt(failwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakeszel.txt.
                #print(failwrite)
                failwrite = ''
            
#----------------------------------------------------------------------------------------#
            #print(ipzel, statusline) # Для тестирования.
                
#---------ЗАНОСИМ ДАННЫЕ В БД (ПИНГИ И СТАТУС СОЕДИНЕНИЯ) ПО ЛОКАЛЬНОМУ IP-АДРЕСУ--------#
        
            data = (ipzel, statusline, pu, purem, timewrite)
            connection = psycopg2.connect(dbn)
            cursor = connection.cursor()
            cursor.execute('INSERT INTO ubajax_zelstatusconline(ipzel, statusline, pu, purem, timewrite)\
                            VALUES(%s,%s,%s,%s,%s)',data)
            connection.commit()
            cursor.close()
            connection.close()
        
            #print('ЗАПИСАНО В БД zelstatusconline') # Для тестирования.
        
#----------------------------------------------------------------------------------------#

#-----------------------ОПРЕДЕЛЯЕМ КАКИЕ МОДУЛИ УСТАНОВЛЕНЫ В СЛОТЫ----------------------#

            slot1con = [] # Создаём пустой список для хранения состояний соединения.
            slot1gain = [] # Создаём пустой список для хранения усилений.         
            if modlist[0] == 4: # Модуль MIME-4xFXO установлен в SLOT 01.
                slotonelocid = 4 # Переменная для записи в БД.
            
                allports = allportsfxo(1) # 1 - это первый слот. Получаем список из 4 элементов.
                                          # Каждый элемент это строка с текстом о состоянии одного порта.
            
                for textport in allports:# Обрабатываем каждый элемент списка.               
                    conport = connect(textport) # Состояние соединения порта.
                    #print(ipzel, conport) # Для тестирования. 
                    slot1con.append(enru(conport)) # Добавляем элемент к списку.
                    #print(conport) # Для тестирования.

                    if flagupdate == 1:               
                        gainport = gain(textport) # Усиление порта по входу и по выходу.
                        slot1gain.append(gainport) # Добавляем элемент к списку.                
                        #print(gainport) # Для тестирования.
                
            elif modlist[0] == 2: # Модуль MIME-2xFXS-2xFXO установлен в SLOT 01.
                slotonelocid = 2 # Переменная для записи в БД.

                allports = allportsfxsfxo(1) # 1 - это первый слот.
            
                for textport in allports:                
                    conport = connect(textport) # Состояние соединения порта.
                    #print(ipzel, conport) # Для тестирования. 
                    slot1con.append(enru(conport)) # Добавляем элемент к списку.
                    #print(conport) # Для тестирования.

                    if flagupdate == 1:               
                        gainport = gain(textport) # Усиление порта по входу и по выходу.
                        slot1gain.append(gainport) # Добавляем элемент к списку.                
                        #print(gainport) # Для тестирования.               

            elif modlist[0] == 0: # Модуль в SLOT 01 не установлен. 
                slotonelocid = 0 # Переменная для записи в БД.
                slot1con = [' ', ' ', ' ', ' ']
                slot1gain = [' ', ' ', ' ', ' ']

            slot2con =[] # Создаём пустой список для хранения состояний соединения.
            slot2gain = [] # Создаём пустой список для хранения усилений.
            if modlist[1] == 4: # Модуль MIME-4xFXO установлен в SLOT 02.
                slottwolocid = 4 # Переменная для записи в БД.
            
                allports = allportsfxo(2) # 2 - это второй слот.
            
                for textport in allports:                             
                    conport = connect(textport) # Состояние соединения порта.
                    #print(ipzel, conport) # Для тестирования. 
                    slot2con.append(enru(conport)) # Добавляем элемент к списку.
                    #print(conport) # Для тестирования.

                    if flagupdate == 1:               
                        gainport = gain(textport) # Усиление порта по входу и по выходу.
                        slot2gain.append(gainport) # Добавляем элемент к списку.                
                        #print(gainport) # Для тестирования.
                            
            elif modlist[1] == 2: # Модуль MIME-2xFXS-2xFXO установлен в SLOT 02.
                slottwolocid = 2 # Переменная для записи в БД.
            
                allports = allportsfxsfxo(2) # 2 - это второй слот.
            
                for textport in allports:                                              
                    conport = connect(textport) # Состояние соединения порта.
                    #print(ipzel, conport) # Для тестирования. 
                    slot2con.append(enru(conport)) # Добавляем элемент к списку.
                    #print(conport) # Для тестирования.

                    if flagupdate == 1:               
                        gainport = gain(textport) # Усиление порта по входу и по выходу.
                        slot2gain.append(gainport) # Добавляем элемент к списку.                
                        #print(gainport) # Для тестирования.
                
            elif modlist[1] == 0: # Модуль в SLOT 02 не установлен.
                slottwolocid = 0 # Переменная для записи в БД.
                slot2con = [' ', ' ', ' ', ' ']
                slot2gain = [' ', ' ', ' ', ' ']
            
#-------------------------------------------------------------------------------------#

#-----------------------ОБРАБОТКА ТЕКСТА ИЗ КОМАНДЫ show run--------------------------#
#-----------------------ЕСЛИ МОДУЛЬ fxs - ЭТО ВСЕГДА АБОНЕНТ--------------------------#

            if flagupdate == 1:
                if slotonelocid != 0:
                    slot1type = []
                    for fxo_n in range(4):
                        fxoport = f'FXO 1/{fxo_n}'
                        #print(fxoport) # Для тестирования.
                        fxo_id = ttext.find(fxoport)
                        #print(fxo_id) # Для тестирования.              
                        if fxo_id != -1:
                            fxo = ttext[fxo_id+10:fxo_id+26]
                            #print(fxo) # Для тестирования.
                            if fxo == 'line-mode 4-wire':
                                slot1type.append('ТЧ')
                            else:
                                slot1type.append('АТС')
                        elif fxo_id == -1:
                            fxoport = f'FXS 1/{fxo_n}'
                            fxo_id = ttext.find(fxoport)
                            if fxo_id != -1:
                                slot1type.append('Абонент')
                            else:
                                slot1type.append('Не определено')
                elif slotonelocid == 0:
                    slot1type = [' ', ' ', ' ', ' ']
                #print(f'МОДУЛЬ 1 --> {slot1type}')
            
                if slottwolocid != 0:        
                    slot2type = []
                    for fxo_n in range(4):
                        fxoport = f'FXO 2/{fxo_n}'
                        #print(fxoport) # Для тестирования.
                        fxo_id = ttext.find(fxoport)
                        #print(fxo_id) # Для тестирования.               
                        if fxo_id != -1:
                            fxo = ttext[fxo_id+10:fxo_id+26]
                            #print(fxo) # Для тестирования.
                            if fxo == 'line-mode 4-wire':
                                slot2type.append('ТЧ')
                            else:
                                slot2type.append('АТС')
                        elif fxo_id == -1:
                            fxoport = f'FXS 2/{fxo_n}'
                            fxo_id = ttext.find(fxoport)
                            if fxo_id != -1:
                                slot2type.append('Абонент')
                            else:
                                slot2type.append('Не определено')
                elif slottwolocid == 0:
                    slot2type = [' ', ' ', ' ', ' ']    
            #print(f'МОДУЛЬ 2 --> {slot2type}')
        
#-------------------------------------------------------------------------------------#
        
            #print('*********************************************************')
        
#-------------------------------------------------------------------------------------#

#-------------------------------------------------------------------------------------#
        
            exitshell() # Выход из shell.

#-------------------------------------------------------------------------------------#
        
#-------------------------------------------------------------------------------------#
            
            tn.close() # Закрытие Телнет-сессии.

#-------------------------------------------------------------------------------------#

#---------------ЗАНОСИМ ДАННЫЕ В БД (СОЕДИНЕНИЕ) ПО ЛОКАЛЬНОМУ IP-АДРЕСУ--------------#
        
            zellist(slot1con, slot2con)
            #print(slot1con) # Для тестирования.
            #print(slot2con) # Для тестирования.
        
            writedb('con', 'loc', ipzel)
           
            #print('ЗАПИСАНО В БД zelslotconloc') # Для тестирования.
        
#-------------------------------------------------------------------------------------#

#--------------ЗАНОСИМ ДАННЫЕ В БД (УСИЛЕНИЕ) ПО ЛОКАЛЬНОМУ IP-АДРЕСУ-----------------#
        
            zellist(slot1gain, slot2gain)

            if flagupdate == 1:
                writedb('gain', 'loc', ipzel)
            
                #print('ЗАПИСАНО В БД zelslotgainloc') # Для тестирования.
            
#-------------------------------------------------------------------------------------#

#--------ЗАНОСИМ ДАННЫЕ В БД (ТЧ или АТС или АБОНЕНТ) ПО ЛОКАЛЬНОМУ IP-АДРЕСУ---------#
        
            zellist(slot1type, slot2type)
                  
            if flagupdate == 1:
                writedb('info', 'loc', ipzel)
            
                #print('ЗАПИСАНО В БД zelslotinfoloc') # Для тестирования.
            
#---------------------------------------------------------------------------------------#
           
#########################################################################################
#--------------------------ДАЛЕЕ КОД ДЛЯ УДАЛЁННОГО УСТРОЙСТВА--------------------------#
#########################################################################################
                
        if purem == 0:

#-------ЗАНОСИМ ДАННЫЕ В БД (Локальный и удалённый IP адрес)ПО ЛОКАЛЬНОМУ IP-АДРЕСУ-----#
#-----------------------------(Тип модуля в слоте устройства)---------------------------#
        
            if flagupdate == 1:
                data = (ipzel, namezellocfrom, slotonelocid, slottwolocid, ipzelrem, 'Ошибка', 0, 0,timewrite)
                #print(data) # Для тестирования.
                connection = psycopg2.connect(dbn)
                cursor = connection.cursor()
                cursor.execute('INSERT INTO ubajax_zelmonbase(ipzel, namezellocfrom, slotonelocid,\
                           slottwolocid, ipzelrem, namezelremfrom, slotoneremid, slottworemid, timewrite)\
                           VALUES(%s,%s,%s,%s,%s,%s,%s,%s,%s)',data)
                connection.commit()
                cursor.close()
                connection.close()
            
                #print('ЗАПИСАНО В БД zelmonbase') # Для тестирования.
            
#----------------------------------------------------------------------------------------#
            
            continue  # Пропускаем эту итерацию цикла и переходим к следующему IP из списка.
        
        elif purem == 1: # Если удалённый Zelax на пинг отозвался.

#---------------------ОТКРЫВАЕМ ТЕЛНЕТ-СЕССИЮ С УДАЛЁННЫМ IP-АДРЕСОМ---------------------#
#---------------------------ВВОДИМ ИМЯ ПОЛЬЗОВАТЕЛЯ И ПАРОЛЬ-----------------------------#
#--------------------------ПОЛУЧАЕМ ИМЯ УДАЛЁННОГО УСТРОЙСТВА----------------------------#

            try:
                tn = telnetlib.Telnet(ipzelrem) # Окрытие Telnet-сессии.
            except Exception: # Исключение.
                failwrite = f'Ошибка Telnet-сессии для IP: {ipzelrem}'
                fail(ipzelrem, failwrite, timewrite)
                write_txt(failwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakeszel.txt.
                #print(failwrite)
                failwrite = ''
                continue # Пропускаем эту итерацию цикла и переходим к следующему IP.    

            # ПРЕДУПРЕЖДЕНИЕ: Перед методом read_very_eager 
            # всегда надо ставить time.sleep(n).
            time.sleep(0.1) # Задержка времени.

            # Получение данных Telnet-сессии.
            text = tn.read_very_eager().decode('utf-8')
            #print(text) # router login:

            if text.find('login:') != -1:
                successwrite = f'Успешное открытие Telnet-сессии для IP: {ipzelrem}'
                success(ipzelrem, successwrite, timewrite)
                #print(successwrite)
                successwrite = ''
                tn.write(to_bytes(login)) # Ввод логина (Логин: admin).
                #tn.write(b'admin\n') # Ввод логина (Логин: admin).
            else:
                failwrite = f'Ошибка доступа к устройству с IP: {ipzelrem}'
                fail(ipzelrem, failwrite, timewrite)
                write_txt(failwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakeszel.txt.
                #print(failwrite)
                failwrite = ''
                tn.close() # Закрытие Телнет-сессии.
                continue # Пропускаем эту итерацию цикла и переходим к следующему IP.
                
            time.sleep(0.1) # Задержка времени.
        
            # Получение данных Telnet-сессии.
            text = tn.read_very_eager().decode('utf-8')
            #print(text) # router Password:
            if text.find('Password:') != -1:
                tn.write(to_bytes(password)) # Ввод пароля (Пароль: admin).
                #tn.write(b'admin\n') # Ввод пароля (Пароль: admin).
            else:
                failwrite = f'Ошибка доступа к устройству с IP: {ipzelrem}'
                fail(ipzelrem, failwrite, timewrite)
                write_txt(failwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakeszel.txt.
                #print(failwrite)
                failwrite = ''
                tn.close() # Закрытие Телнет-сессии.
                continue # Пропускаем эту итерацию цикла и переходим к следующему IP.
                
            time.sleep(0.5) # Задержка времени.
        
            # Получение данных Telnet-сессии.
            text = tn.read_very_eager().decode('utf-8')
            #print(text) # router#

            try:
                namezelremfrom = text[:-1].split('\n')[1] # Получения среза. 
                                            # От начала принятой строки до
                                            # предпоследнего элемента.                               
                # Вывод на печать имени устройства.
                #print('Имя устройства --> ', namezelremfrom)
                #print('---------------------------------------------------------')
            except Exception: # Исключение.
                failwrite = f'Ошибка авторизации для IP: {ipzelrem}'
                fail(ipzelrem, failwrite, timewrite)
                write_txt(failwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakeszel.txt.
                #print(failwrite)
                failwrite = ''
                continue # Пропускаем эту итерацию цикла и переходим к следующему IP.

#----------------------------------------------------------------------------------------#        

#-------------------------------ПЕРЕХОД В ОБОЛОЧКУ shell---------------------------------#
        
            text = shell()
            #print(text) Для тестирования.(router(shell):)

            if text.find('(shell)#') == -1:
                failwrite = f'Ошибка ввода команды Shell в IP: {ipzelrem}'
                fail(ipzelrem, failwrite, timewrite)
                write_txt(failwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakeszel.txt.
                #print(failwrite)
                failwrite = ''
                tn.write(b'reboot\n') # Перегружаем устройство.
                                      # Телнет сессия закрывается автоматически
                continue   # Пропускаем эту итерацию цикла и 
                           # переходим к следующему IP.

#----------------------------------------------------------------------------------------#

            if pu == 0:

#-------ОПРЕДЕЛЯЕМ УСТАНОВЛЕНО ЛИ СОЕДИНЕНИЕ С УДАЛЁННЫМ (ЛОКАЛЬНЫМ) СЕРВЕРОМ------------#
        
                tn.write(b'show voice-connections active\n')
        
                time.sleep(0.1) # Задержка времени.
        
                # Получение данных Telnet-сессии.
                text = tn.read_very_eager().decode('utf-8')

                findcon = text.find('connect')
                if findcon != -1:
                    statusline = True
                    successwrite = f'Соединение с удалённым сервером {ipzelrem} установлено'
                    success(ipzel, successwrite, timewrite)
                    #print(successwrite)
                    successwrite = ''
                elif findcon == -1:
                    statusline = False
                    failwrite = f'Соединение с удалённым сервером {ipzelrem} не установлено'
                    fail(ipzel, failwrite, timewrite)
                    write_txt(failwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakeszel.txt.
                    #print(failwrite)
                    failwrite = ''
            
#----------------------------------------------------------------------------------------#

#---------ЗАНОСИМ ДАННЫЕ В БД (ПИНГИ И СТАТУС СОЕДИНЕНИЯ) ПО ЛОКАЛЬНОМУ IP-АДРЕСУ--------#
        
                data = (ipzel, statusline, pu, purem, timewrite)
                connection = psycopg2.connect(dbn)
                cursor = connection.cursor()
                cursor.execute('INSERT INTO ubajax_zelstatusconline(ipzel, statusline, pu, purem, timewrite)\
                                VALUES(%s,%s,%s,%s,%s)',data)
                connection.commit()
                cursor.close()
                connection.close()
        
                #print('ЗАПИСАНО В БД zelstatusconline') # Для тестирования.
        
#----------------------------------------------------------------------------------------#                    

#---------------ВВОД КОМАНДЫ show system mims И ПОЛУЧЕНИЕ ТЕКСТА textmins----------------#

            textmins = showsysmins()

#----------------------------------------------------------------------------------------#

#--------------ПОЛУЧЕНИЕ ИЗ textmins наполненности слотов модулями и их тип--------------#
        
            modlist = fmodulem(textmins) # [4, 4] или [4, 2] или [4, 0]
        
#----------------------------------------------------------------------------------------#        

#---------------------ВВОД КОМАНДЫ show run И ПОЛУЧЕНИЕ ТЕКСТА ttext---------------------#
                        
            ttext = showrun() # Вызов функции showrun().
            #print(ttext) # Для тестирования.

#----------------------------------------------------------------------------------------#

#----------------------ОПРЕДЕЛЯЕМ КАКИЕ МОДУЛИ УСТАНОВЛЕНЫ В СЛОТЫ-----------------------#

            slot1con = [] # Создаём пустой список для хранения состояний соединения.
            slot1gain = [] # Создаём пустой список для хранения усилений.         
            if modlist[0] == 4: # Модуль MIME-4xFXO установлен в SLOT 01.
                slotoneremid = 4 # Переменная для записи в БД.
            
                allports = allportsfxo(1) # 1 - это первый слот. Получаем список из 4 элементов.
                                      # Каждый элемент это строка с текстом о состоянии одного порта.
            
                for textport in allports:# Обрабатываем каждый элемент списка.                
                    conport = connect(textport) # Состояние соединения порта.
                    #print(ipzel, conport) # Для тестирования. 
                    slot1con.append(enru(conport)) # Добавляем элемент к списку.
                    #print(conport) # Для тестирования.

                    if flagupdate == 1:               
                        gainport = gain(textport) # Усиление порта по входу и по выходу.
                        slot1gain.append(gainport) # Добавляем элемент к списку.                
                        #print(gainport) # Для тестирования.
                
            elif modlist[0] == 2: # Модуль MIME-2xFXS-2xFXO установлен в SLOT 01.
                slotoneremid = 2 # Переменная для записи в БД.

                allports = allportsfxsfxo(1) # 1 - это первый слот.
            
                for textport in allports:                
                    conport = connect(textport) # Состояние соединения порта.
                    #print(ipzel, conport) # Для тестирования. 
                    slot1con.append(enru(conport)) # Добавляем элемент к списку.
                    #print(conport) # Для тестирования.

                    if flagupdate == 1:               
                        gainport = gain(textport) # Усиление порта по входу и по выходу.
                        slot1gain.append(gainport) # Добавляем элемент к списку.                
                        #print(gainport) # Для тестирования.

            elif modlist[0] == 0: # Модуль в SLOT 01 не установлен. 
                slotoneremid = 0 # Переменная для записи в БД.
                slot1con = [' ', ' ', ' ', ' ']
                slot1gain = [' ', ' ', ' ', ' ']
            
            slot2con =[] # Создаём пустой список для хранения состояний соединения.
            slot2gain = [] # Создаём пустой список для хранения усилений.
            if modlist[1] == 4: # Модуль MIME-4xFXO установлен в SLOT 02.
                slottworemid = 4 # Переменная для записи в БД.
            
                allports = allportsfxo(2) # 2 - это второй слот.
            
                for textport in allports:                             
                    conport = connect(textport) # Состояние соединения порта.
                    #print(ipzel, conport) # Для тестирования. 
                    slot2con.append(enru(conport)) # Добавляем элемент к списку.
                    #print(conport) # Для тестирования.

                    if flagupdate == 1:               
                        gainport = gain(textport) # Усиление порта по входу и по выходу.
                        slot2gain.append(gainport) # Добавляем элемент к списку.                
                        #print(gainport) # Для тестирования.
            
            elif modlist[1] == 2: # Модуль MIME-2xFXS-2xFXO установлен в SLOT 02.
                slottworemid = 2 # Переменная для записи в БД.
            
                allports = allportsfxsfxo(2) # 2 - это второй слот.
            
                for textport in allports:                                             
                    conport = connect(textport) # Состояние соединения порта.
                    #print(ipzel, conport) # Для тестирования. 
                    slot2con.append(enru(conport)) # Добавляем элемент к списку.
                    #print(conport) # Для тестирования.

                    if flagupdate == 1:               
                        gainport = gain(textport) # Усиление порта по входу и по выходу.
                        slot2gain.append(gainport) # Добавляем элемент к списку.                
                        #print(gainport) # Для тестирования.

            elif modlist[1] == 0: # Модуль в SLOT 02 не установлен.
                slottworemid = 0 # Переменная для записи в БД.
                slot2con = [' ', ' ', ' ', ' ']
                slot2gain = [' ', ' ', ' ', ' ']
            
#----------------------------------------------------------------------------------------#

#-------------------------ОБРАБОТКА ТЕКСТА ИЗ КОМАНДЫ show run---------------------------#
#-------------------------ЕСЛИ МОДУЛЬ fxs - ЭТО ВСЕГДА АБОНЕНТ---------------------------#

            if flagupdate == 1:
                if slotoneremid != 0:
                    slot1type = []
                    for fxo_n in range(4):
                        fxoport = f'FXO 1/{fxo_n}'
                        #print(fxoport) # Для тестирования.
                        fxo_id = ttext.find(fxoport)
                        #print(fxo_id) # Для тестирования.             
                        if fxo_id != -1:
                            fxo = ttext[fxo_id+10:fxo_id+26]
                            #print(fxo) # Для тестирования.
                            if fxo == 'line-mode 4-wire':
                                slot1type.append('ТЧ')
                            else:
                                slot1type.append('АТС')
                        elif fxo_id == -1:
                            fxoport = f'FXS 1/{fxo_n}'
                            fxo_id = ttext.find(fxoport)
                            if fxo_id != -1:
                                slot1type.append('Абонент')
                            else:
                                slot1type.append('Не определено')
                elif slotoneremid == 0:
                    slot1type = [' ', ' ', ' ', ' ']
                #print(f'МОДУЛЬ 1 --> {slot1type}')
            
                if slottworemid != 0:        
                    slot2type = []
                    for fxo_n in range(4):
                        fxoport = f'FXO 2/{fxo_n}'
                        #print(fxoport) # Для тестирования.
                        fxo_id = ttext.find(fxoport)
                        #print(fxo_id) # Для тестирования.            
                        if fxo_id != -1:
                            fxo = ttext[fxo_id+10:fxo_id+26]
                            #print(fxo) # Для тестирования.
                            if fxo == 'line-mode 4-wire':
                                slot2type.append('ТЧ')
                            else:
                                slot2type.append('АТС')
                        elif fxo_id == -1:
                            fxoport = f'FXS 2/{fxo_n}'
                            fxo_id = ttext.find(fxoport)
                            if fxo_id != -1:
                                slot2type.append('Абонент')
                            else:
                                slot2type.append('Не определено')
                elif slottworemid == 0:
                    slot2type = [' ', ' ', ' ', ' ']    
            #print(f'МОДУЛЬ 2 --> {slot2type}')
        
#----------------------------------------------------------------------------------------#
        
            #print('*********************************************************')
        
#----------------------------------------------------------------------------------------#

#----------------------------------------------------------------------------------------#
        
            exitshell() # Выход из shell.

#----------------------------------------------------------------------------------------#
    
#----------------------------------------------------------------------------------------#       
            
            tn.close() # Закрытие Телнет-сессии.

#----------------------------------------------------------------------------------------#
       
#----------------ЗАНОСИМ ДАННЫЕ В БД (СОЕДИНЕНИЕ)ПО УДАЛЁННОМУ IP-АДРЕСУ-----------------#
        
            zellist(slot1con, slot2con)
        
            writedb('con', 'rem', ipzelrem)
       
            #print('ЗАПИСАНО В БД zelslotconrem') # Для тестирования.
        
#----------------------------------------------------------------------------------------#

#------------------ЗАНОСИМ ДАННЫЕ В БД (УСИЛЕНИЕ)ПО УДАЛЁННОМУ IP-АДРЕСУ-----------------#
        
            zellist(slot1gain, slot2gain)
        
            if flagupdate == 1:
                writedb('gain', 'rem', ipzelrem)
            
                #print('ЗАПИСАНО В БД zelslotgainrem') # Для тестирования.
            
#----------------------------------------------------------------------------------------#

#-----------ЗАНОСИМ ДАННЫЕ В БД (ТЧ или АТС или АБОНЕНТ)ПО УДАЛЁННОМУ IP-АДРЕСУ----------#
        
            zellist(slot1type, slot2type)
        
            if flagupdate == 1:
                writedb('info', 'rem', ipzelrem)
                        
                #print('ЗАПИСАНО В БД zelslotinforem') # Для тестирования.
            
#----------------------------------------------------------------------------------------#

#-------ЗАНОСИМ ДАННЫЕ В БД (Локальный и удалённый IP адрес)ПО ЛОКАЛЬНОМУ IP-АДРЕСУ------#
#----------------------------(Тип модуля в слоте устройства)-----------------------------#
        
        if flagupdate == 1:
            data = (ipzel, namezellocfrom, slotonelocid, slottwolocid, ipzelrem, namezelremfrom, slotoneremid, slottworemid,timewrite)
            #print(data) # Для тестирования.
            connection = psycopg2.connect(dbn)
            cursor = connection.cursor()
            cursor.execute('INSERT INTO ubajax_zelmonbase(ipzel, namezellocfrom, slotonelocid,\
                           slottwolocid, ipzelrem, namezelremfrom, slotoneremid, slottworemid, timewrite)\
                           VALUES(%s,%s,%s,%s,%s,%s,%s,%s,%s)',data)
            connection.commit()
            cursor.close()
            connection.close()
            
            #print('ЗАПИСАНО В БД zelmonbase') # Для тестирования.
            
#----------------------------------------------------------------------------------------#

#--------------------------КОНЕЦ ЦИКЛА ОБРАБОТКИ ОДНОГО IP-АДРЕСА------------------------#

#------------------ЭТОТ ФРАГМЕНТ СООТВЕТСТВУЕТ ПУНКТУ 6 ПЛАНА ПРОГРАММЫ------------------#             
        
    tt = timewritestart + timedelta(hours=1)
    if tt <= timewrite:
        flagupdate = 1
        timewritestart = datetime.now()
        # Обновляем данные со всех устройств. После обновления всех IP flagupdate = 0.
    else:
        flagupdate = 0
        
#---------------------------------------------------------------------------------------#

#-------------------------КОНЕЦ ЦИКЛА ОБРАБОТКИ СПИСКА IP-АДРЕСОВ-----------------------#

        


