import requests as r
import time
import psycopg2
from datetime import datetime, timedelta
import subprocess
import telnetlib

#---------------------------------------------ФУНКЦИИ ПРОГРАММЫ---------------------------------------------#

#-----------------------------------------Функция pingurl()--------------------------------------#            
# Функция pingurl(url, typeos) для выполнения команды ping.                                      #
# Принимает на вхох IP-адрес устройства (url) и тип операционной системы (typeos)                #
# 'w' (Windows) или 'l' (Linux).                                                                 #
# Возвращает 1 - если ping удался, 0 - если ping не удался.                                      #
#------------------------------------------------------------------------------------------------#

def pingurl(url, typeos):
    if typeos == 'w':
        command = ['ping', '-n', '1', url]  # For Windows.
    elif typeos == 'l': # Это буква 'l' - linux
        command = ['ping', '-c', '1', url]  # For Linux.
    ping = subprocess.call(command)
    if ping == 1: # Если url на ping не отозвался.
        #subprocess.Popen('taskkill /im ping.exe /f')
        return 0 
    elif ping == 0: # Если url на ping отозвался.        
        return 1

#------------------------------------------Конец функции----------------------------------------#

#---------------------------------------Функция geturlrem()-------------------------------------#
# Функция geturlrem(dbn, url) для получения из БД IP-адреса удалённого РРС.                     #
# Принимает на вход строку с данными (dbn) для подключения к БД, IP-адрес локального РРС (url). # 
# Возвращает IP-адрес удалённого РРС (urlrem), флаг (flag) указывающий на успех или провал      #                         #
# и в связи с этим выбор действия (принимает значения 'success' - успех (по умолчанию),         #
# 'fail' - провал), строку с описанием успешного или провального действия (sucfailwrite).       #
#-----------------------------------------------------------------------------------------------#

def geturlrem(dbn, url):
    connection = psycopg2.connect(dbn)
    cursor = connection.cursor()
    # Получение удалённого IP-адреса.
    try: # Попытка.
        cursor.execute('SELECT ipubntremote from ubajax_ubntmodeltest WHERE ipubntone=%s', (url,))
        #urlrem = cursor.fetchone() # ('10.1.123.110',)
        urlrem = cursor.fetchone()[0] # '10.1.123.110'
        # В переменную sucfailwrite, записываем успешное действие - 
        # 'Удалённый IP-адрес получен из БД.'
        sucfailwrite = f'IP-адрес удалённого РРС получен из БД --> {urlrem}.'
        flag = 's'
    except Exception: # Исключение.
        # В переменную sucfailwrite, записываем ошибку - 
        # 'Ошибка получения удалённого IP-адреса из БД.'
        sucfailwrite = 'Ошибка получения IP-адреса удалённого РРС из БД.'
        flag = 'f'
    cursor.close()
    connection.close()
    return urlrem, flag, sucfailwrite # Возвращается кортеж (urlrem, flag, sucfailwrite).
        
#-----------------------------------------Конец функции-----------------------------------------#

#----------------------------------------Функция sucfail()--------------------------------------#
# Функция sucfail(dbn, url, sucfailwrite, flag='success') для записи в БД успешных и провальных #
# действий по доступу к РРС. Принимает на вход строку с данными (dbn) для подключения           #
# к БД, IP-адрес РРС (url), флаг (flag) указывающий на успех или провал и в связи с этим        #
# выбор действия (принимает значения 'success' - успех (по умолчанию), 'fail' - провал),        #
# строку с описанием успешного или провального действия (sucfailwrite).                         #
#-----------------------------------------------------------------------------------------------#
        
def sucfail(dbn, url, sucfailwrite, timewrite, flag='success'):
    connection = psycopg2.connect(dbn)
    cursor = connection.cursor()
    cursor.execute(f'INSERT INTO ubajax_ub{flag}(url, {flag}write, timewrite)\
                    VALUES(%s,%s,%s)', (url, sucfailwrite, timewrite))
    connection.commit()
    cursor.close()
    connection.close()

#-----------------------------------------Конец функции-----------------------------------------#

#---------------------------------------Функция write_txt()-------------------------------------#
# Функция write_txt(sucfailwrite, timewrite) для записи провальных действий(ошибок)             #
# в текстовый файл logmistakes.txt.                                                             #
# Принимает на вход строку (sucfailwrite) с описанием провального действия(ошибки) и            #
# текущего времени (timewrite).                                                                 #
#-----------------------------------------------------------------------------------------------#      
    
def write_txt(sucfailwrite, timewrite):
#################################################################################################
    with open('/home/zarya/project/ubntserver/sell/logmistakes.txt', 'a', encoding='utf-8') as f:
   # with open('logmistakes.txt', 'a', encoding='utf-8') as f:# Для тестировании на Windows.
#################################################################################################
        f.write(f'{timewrite}-->{sucfailwrite}' + '\n') # '\n' - для перехода на новую строку.
      
#------------------------------------------Конец функции----------------------------------------#   

#-----------------------------------------Функция ubreq()---------------------------------------#
# Функция ubreq(url, payload, http='http') для открытия http(s)- сессии, ввода логина и пароля. #
# Принимает на вход IP-адрес РРС, словарь payload с Логином и Паролем,                          #
# http или https взависимости от настроек РРС.                                                  #
# Возвращает кортеж состоящий из ses, flag ('s' - успех, 'f' - ошибка), sucfailwrite.           #
#-----------------------------------------------------------------------------------------------#

def ubreq(url, payload, httpflag='http'):
    ses = r.Session()
    try: # Попыткаю
        sget = ses.get(f'{httpflag}://{url}/login.cgi?uri=/')         
        spost = ses.post(f'{httpflag}://{url}/login.cgi', params=payload)
        sucfailwrite = 'Авторизация прошла успешно.'
        flag = 's'
    except Exception: # Исключение.
        sucfailwrite = f'Авторизация прошла не удачно для {url}. Проверьте Логин и Пароль.'
        flag = 'f'
    return ses, flag, sucfailwrite

#------------------------------------------Конец функции----------------------------------------#

#-----------------------------------------Функция ubjson()--------------------------------------#
# Функция ubjson(ses,url, http='http') для получения json.                                      #
# Принимает на вход открытую сессию ses, IP-адрес РРС, http или https взависимости              #
# от настроек РРС.                                                                              #
# Возвращает кортеж состоящий из sgetjson, flag ('s' - успех, 'f' - ошибка), sucfailwrite.      #
#-----------------------------------------------------------------------------------------------#

def ubjson(ses, url, httpflag='http'):
    try: # Попытка.
        sgetjson = ses.get(f'{httpflag}://{url}/status.cgi').json()
        #print(sgetjson)
        sucfailwrite = 'JSON получен.'
        flag = 's'
    except Exception: # Исключение.
        sucfailwrite = f'JSON не получен для {url}.'
        flag = 'f'    
    return sgetjson, flag, sucfailwrite

#------------------------------------------Конец функции----------------------------------------#

#-----------------------------------Функция getdatajsonalways()---------------------------------#
# Функция getdatajsonalways(url, sgetjson) для получения данных из JSON                         #
# и формирования из них списка data. Принимает на вход IP-адрес РРС (url), данные в формате     #
# JSON (sgetjson). Получает из JSON необходимые данные и формирует список data.                 #
# Возвращает список data, flag ('s' - успех, 'f' - ошибка), описание ошибки (sucfailwrite).     # 
#-----------------------------------------------------------------------------------------------#

def getdatajsonalways(url, sgetjson):
    ipubnttwo = url # ipubnttwo - задумывался как IP-адрес локальной РРС полученный 
                    # из устройства (РРС), но в процессе разработки изменилась методика 
                    # получения данных и в полученном блоке данных IP-адрес локальной РРС
                    # отсутствует. Поэтому присваиваем IP-адрес из БД.
    try: # Попытка.        
        # Получение из JSON уровней приёма для локальной РРС.
        udprml0 = sgetjson['airfiber']['rxpower0']   # -54. Уровень приёма локальной РРС.
        udprml1 = sgetjson['airfiber']['rxpower1']   # -53. Уровень приёма локальной РРС.

        # Получение из JSON уровней приёма для удалённой РРС.
        # udprmr0flag и udprmr1flag - флаги для получения уровней приёма удалённой РРС.
        udprmr0flag = sgetjson['airfiber']['remote_rxpower0']  # -57 или может быть -1000.
        udprmr1flag = sgetjson['airfiber']['remote_rxpower1']  # -58 или может быть -1000.
        if udprmr0flag == -1000:
            udprmr0 = 0 # Уровень приёма удалённой РРС.
            udprmr1 = 0 # Уровень приёма удалённой РРС.
        elif udprmr1flag == -1000:
            udprmr1 = 0 # Уровень приёма удалённой РРС.
            udprmr0 = 0 # Уровень приёма удалённой РРС.
        else:
            udprmr0 = udprmr0flag # Уровень приёма удалённой РРС.
            udprmr1 = udprmr1flag # Уровень приёма удалённой РРС.
               
        udspeedl = round(sgetjson['airfiber']['rxcapacity']/1000000, 2)   # 301.60. Скорость приёма лок. РРС.
        udspeedr = round(sgetjson['airfiber']['txcapacity']/1000000, 2)   # 302.30. Скорость приёма удал. РРС.

        ipubnttworemflag = sgetjson['airfiber']['remote_ip'] # Флаг для получения IP-адреса удалённой РРС.
        
        data = [ipubnttwo, ipubnttworemflag, udprml0, udprml1, udprmr0, udprmr1, udspeedl, udspeedr]
        #print(data) # Для тестирования.
        sucfailwrite = 'Данные об уровне приёма и ёмкости из JSON получены'
        flag = 's'
    except Exception: # Исключение.
        data = [ipubnttwo, 'f', 0, 0, 0, 0, 0.0, 0.0]
        #print(data) # Для тестирования.
        sucfailwrite = f'Данные об уровне приёма и ёмкости для {url} из JSON не получены'
        flag = 'f'
            
    return data, flag, sucfailwrite 

#------------------------------------------Конец функции----------------------------------------#

#------------------------------------Функция getdatajsononce()----------------------------------#
# Функция getdatajsononce(url, sgetjson) для получения данных из JSON и формирования из них     #
# строки detail_txt. Принимает на вход IP-адрес РРС (url), данные  в формате JSON (sgetjson).   #
# Получает из JSON необходимые данные и формирует строку detail_txt. Возвращает строку          #
# detail_txt, flag ('s' - успех, 'f' - ошибка), описание ошибки (sucfailwrite).                 # 
#-----------------------------------------------------------------------------------------------#

def getdatajsononce(url, remurl, sgetjson):
    #print(sgetjson) # Для тестирования.
    try: # Попытка.                
        namerrs = sgetjson['host']['hostname']
        #print(namerrs) # Для тестирования.
        namerrl = sgetjson['wireless']['essid']
        #print(namerrl) # Для тестирования.
        distrrl = str(sgetjson['wireless']['distance']/1000)
        #print(distrrl) # Для тестирования.        
        rx_freq = str(sgetjson['airfiber']['rx_frequency']/1000)
        #print(rx_freq) # Для тестирования.        
        tx_freq = str(sgetjson['airfiber']['tx_frequency']/1000)
        #print(tx_freq) # Для тестирования.        
        rxchanbw = sgetjson['airfiber']['rxchanbw']
        #print(rxchanbw) # Для тестирования.        
        txmodrate = sgetjson['airfiber']['txmodrate']
        #print(txmodrate) # Для тестирования.        
        linkmode = sgetjson['airfiber']['linkmode']
        #print(linkmode) # Для тестирования.
        #detail_txt = namerrs+'&'+namerrl+'&'+distrrl+'&'+rx_freq+'&'+tx_freq+'&'+rxchanbw+'&'+txmodrate+'&'+linkmode 
        detail_txt = f'{namerrs} {namerrl} {distrrl} {rx_freq} {tx_freq} {rxchanbw} {txmodrate} {linkmode} {remurl}' 
        #print(f'ТЕСТИРОВАНИЕ--->{detail_txt}') # Для тестирования.
        sucfailwrite = 'Второстепенные данные из JSON получены'
        flag = 's'
    except Exception: # Исключение.
        detail_txt = 'FAIL&FAIL&FAIL&FAIL&FAIL&FAIL&FAIL&FAIL' 
        #print(f'ТЕСТИРОВАНИЕ--->{detail_txt}') # Для тестирования.
        sucfailwrite = f'Второстепенные данные для {url} из JSON не получены'
        flag = 'f'
            
    return detail_txt, flag, sucfailwrite

#------------------------------------------Конец функции----------------------------------------#

#---------------------------------------Функция dotupledata()-----------------------------------#
# Функция dotupledata(data, detail_txt, timewrite) для преобразования списка data в кортеж.     #
# Принимает на вход список с данными (data), время получения (обработки) данных (timewrite).    #
# Добавляет timewrite в список data. Возвращает кортеж с данными (data) для записи в БД.        #
#-----------------------------------------------------------------------------------------------#

def dotupledata(data, markeriprem, pu, purem, timewrite):
    if markeriprem == False:
        return data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7],\
               markeriprem, pu, purem, timewrite
    elif markeriprem == True:
        return data[1], data[0], data[2], data[3], data[4], data[5], data[6], data[7],\
               markeriprem, pu, purem, timewrite
#------------------------------------------Конец функции----------------------------------------#

#-------------------------------------Функция writedatatodb()-----------------------------------#
# Функция writedatatodb(dbn, data) для записи в БД данных (data) полученных из JSON.            #
# Принимает на вход строку с данными (dbn) для подключения к БД, кортеж (data) с данными        #
# из JSON.                                                                                      #
#-----------------------------------------------------------------------------------------------#

def writedatatodb(dbn, data):
    connection = psycopg2.connect(dbn)
    cursor = connection.cursor()    
    dt = 'INSERT INTO ubajax_dataubntalways(ipubnttwo, ipubnttworem, udprml0, udprml1,\
          udprmr0, udprmr1, udspeedl, udspeedr, markeriprem, pu, purem, timewrite)\
          VALUES(%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)'          
    cursor.execute(dt, data)
    connection.commit()
    cursor.close()
    connection.close()

#------------------------------------------Конец функции----------------------------------------#

#-----------------------------------Функция writedetailtxttodb()--------------------------------#
# Функция writedetailtxttodb(dbn, detail_txt, url) для записи в БД строки с данными             #
# (detail_txt). Принимает на вход строку с данными (dbn) для подключения к БД,                  #
# и строку (detail_txt).                                                                        # 
#-----------------------------------------------------------------------------------------------#

def writedetailtxttodb(dbn, detail_txt, url):
    connection = psycopg2.connect(dbn)
    cursor = connection.cursor()    
    dt = 'UPDATE ubajax_ubntmodeltest SET detail=%s WHERE ipubntone=%s'          
    cursor.execute(dt, (detail_txt, url))
    connection.commit()
    cursor.close()
    connection.close()

#-----------------------------------------------Конец функции-----------------------------------#
       
#--------------------------------------------------Функция--------------------------------------#            
# Функция to_bytes(line) для формирования байтовой строки.                                      #
# Принимает на вход строку типа 'show controller fxo 1/0'.                                      #
# Возвращает байтовую строку строку b'show controller fxo 1/0\n'.                               #
#-----------------------------------------------------------------------------------------------#

def to_bytes(line):
    return f'{line}\n'.encode('utf-8')

#------------------------------------------Конец функции----------------------------------------#

#-------------------------------------Функция getdatalcalways()---------------------------------#            
# Функция getdatalcalways(url, text, markeriprem, pu, purem, timewrite) для получения данных    #
# (Уровень приёма и ёмкость)из РРС Alcoma. Принимает на вход IP-адрес РРС Alcoma (url),строку с #
# данными типа (text), время создания (обработки) (timewrite). Возвращает кортеж с данными      #
# (data), flag ('s' - успех, 'f' - ошибка), описание ошибки (sucfailwrite).                     #
#-----------------------------------------------------------------------------------------------#

def getdatalcalways(url, text, markeriprem, pu, purem, timewrite):
    #print(text) # Для тестирования.
    try: # Попытка.
        locip = text.find('Local IP')
        ipubnttwo = text[locip+16:locip+27]
        
        remip = text.find('Remote IP')
        ipubnttworem = text[remip+17:remip+28]
        
        rslloc = text.find('RSL Status')
        udprml0 = int(float(text[rslloc+18:rslloc+24]))
        udprml1 = udprml0

        rslrem = text.find('Far End RSL Status')
        udprmr0 = int(float(text[rslrem+26:rslrem+32]))
        udprmr1 = udprmr0

        speedloc = text.find('Mode')
        udspeedl = float(text[speedloc+12:speedloc+14])
        udspeedr = udspeedl

        data = (ipubnttwo, ipubnttworem, udprml0, udprml1, udprmr0, udprmr1, udspeedl, udspeedr,
                markeriprem, pu, purem, timewrite)
        #print(data) # Для тестирования.
        sucfailwrite = 'Данные об уровне приёма и ёмкости получены'
        flag = 's'
    except Exception: # Исключение.
        data = (url, 'f', 0, 0, 0, 0, 0.0, 0.0, False, pu, purem, timewrite)
        #print(data) # Для тестирования.
        sucfailwrite = f'Данные об уровне приёма и ёмкости для {url} не получены'
        flag = 'f'
            
    return data, flag, sucfailwrite 
        
#-----------------------------------------------Конец функции-----------------------------------#

#------------------------------------Функция getdatalcononce()----------------------------------#
# Функция getdatalcononce(url, remurl, text, timewrite) для получения строки detail_txt с       #
# параметрами РРС Alcoma. Принимает на вход IP-адрес РРС Alcoma (url),строку с данными типа     #
# некоторыми (text), время создания (обработки) (timewrite). Возвращает кортеж с данными        #
# (detail_txt), flag ('s' - успех, 'f' - ошибка), описание ошибки (sucfailwrite).               # 
#-----------------------------------------------------------------------------------------------#

def getdatalcononce(url, remurl, text, timewrite):
    #print(text) # Для тестирования.
    try: # Попытка.
        namerrsloc = text.find('Local Host')
        namerrs = text[namerrsloc+18:namerrsloc+27]
        #print(namerrs) # Для тестирования.
        namerrsrem = text.find('Remote Host')
        nrrsr = text[namerrsrem+19:namerrsrem+29]
        #print(nrrsr) # Для тестирования.
        namerrl = namerrs + '-' + nrrsr
        #print(namerrl) # Для тестирования.
        distrrl = '20.2'
        #print(distrrl) # Для тестирования.
        rxfreq = text.find('Rx Freq')
        rx_freq = str(float(text[rxfreq+15:rxfreq+21])*1000)
        #print(rx_freq) # Для тестирования.
        txfreq = text.find('Tx Freq')
        tx_freq = str(float(text[txfreq+15:txfreq+21])*1000)
        #print(tx_freq) # Для тестирования.
        rxch = text.find('Mode')
        rxchanbw = text[rxch+22:rxch+27]
        #print(rxchanbw) # Для тестирования.        
        txmodrate = '--'
        #print(txmodrate) # Для тестирования.        
        linkmode = 'master'
        #print(linkmode) # Для тестирования.
        #detail_txt = namerrs+'&'+namerrl+'&'+distrrl+'&'+rx_freq+'&'+tx_freq+'&'+rxchanbw+'&'+txmodrate+'&'+linkmode 
        detail_txt = f'{namerrl} {namerrl} {distrrl} {rx_freq} {tx_freq} {rxchanbw} {txmodrate} {linkmode} {remurl}' 
        #print(f'ТЕСТИРОВАНИЕ--->{detail_txt}') # Для тестирования.
        sucfailwrite = 'Второстепенные данные получены'
        flag = 's'
    except Exception: # Исключение.
        detail_txt = 'FAIL&FAIL&FAIL&FAIL&FAIL&FAIL&FAIL&FAIL' 
        #print(f'ТЕСТИРОВАНИЕ--->{detail_txt}') # Для тестирования.
        sucfailwrite = f'Второстепенные данные для {url} не получены'
        flag = 'f'
            
    return detail_txt, flag, sucfailwrite

#-----------------------------------------------Конец функции----------------------------------------#
    
#-----------------------------------------------КОНЕЦ ФУНКЦИЙ-----------------------------------------------#


#############################################################################################################
#############################################################################################################
#############################################################################################################

#############################################################################################################
#--------------------------------------НАЧАЛО ПРОГРАММЫ МОНИТОРИНГА-----------------------------------------#
#############################################################################################################

#-----------------------------------------------------------------------------------------------------------#

timewritestart = datetime.now() # При старте программы получаем и запоминаем 
                                # в переменной timewritestart текущую дату и время.                                
flagupdate = 1 # Для уменьшения нагрузки на процессор сервера, второстепенные данные
               # (которые не меняются - являются настроечными данными) будут обновляться               
               # и записываться в БД один раз в час, или при перезагрузке
               # (рестарте программы мониторинга).
               #                В БД записываются следующие данные:
               #
               #    При первом запуске и всегда:
               # udprml0 - Уровень приёма (0) локальной РРС (для примера -54).
               # udprml1 - Уровень приёма (1) локальной РРС (для примера -53).
               # udprmr0 - Уровень приёма (0) удалённой РРС (для примера -57).
               # udprmr1 - Уровень приёма (1) удалённой РРС (для примера -58).
               # udspeedl - Пропускная способность локальной РРС (для примера 301.60).
               # udspeedr - Пропускная способность удалённой РРС (для примера 302.30).
               #
               #    При первом запуске и каждый час:
               # namerrl - Название (Имя) радиорелейной линии (РРЛ).
               # namerrs - Название (Имя) радиорелейной станции (РРС).
               # distrrl - Длина РРЛ.
               # rx_freq - Частота приёма локальной РРС.
               # tx_freq - Частота передачи локальной РРС.
               # rxchanbw - Ширина полосы пропускания приёмопередатчика РРС (Для примера 28MHz).
               # txmodrate - Модуляция (Для примера 8х).
               # linkmode - Ведущий/Ведомый (Для примера master).
               # data_txt - Запись строки с данными в текстовый файл.
               
#-----------------------------------------------------------------------------------------------------------#

#--------------------------ПОЛУЧЕНИЕ ИЗ ФАЙЛА config ДАННЫХ ДЛЯ ДОСТУПА К БД--------------------------------#
#--------------------ЗАПИСЬ УСПЕХА И ОШИБКИ В БД И ЗАПИСЬ ОШИБКИ В ТЕКСТОВЫЙ ФАЙЛ---------------------------#               

timewrite = datetime.now() # Присваиваем переменной timewrite текущую дату и время.
#print(timewrite) # Для тестирования. 
try: # Попытка.
#############################################################################################################
    with open('/home/zarya/project/ubntserver/sell/config', 'r') as f: # Для сервера 10.1.7.155.
   # with open('config', 'r') as f: # Для тестировании на Windows.
#############################################################################################################
        dbn = f.read() # Присваиваем переменной dbn строку с данными для доступа к БД.
    #print(dbn) # Для тестирования.
    # В переменную sucfailwrite, записываем успешное действие - 
    # 'Авторизационные данные для доступа к БД получены.'
    sucfailwrite = 'Авторизационные данные для доступа к БД получены.'
    sucfail(dbn, 'ОБЩАЯ', sucfailwrite, timewrite) # Вызов функции для записи успеха в БД.
    sucfailwrite = '' # Обнуляем переменную.
except Exception: # Исключение.
    # В переменную sucfailwrite, записываем ошибку - 
    # 'Ошибка получения авторизационных данных для доступа к БД,
    # Проверьте данные в файле "config"'
    sucfailwrite = 'Ошибка получения авторизационных данных для доступа к БД,\
                    проверьте данные в файле "config"'
    # Так как авторизационные данные для доступа к БД не получены, то записать ошибку в БД мы не можем.
    # Ошибку запишем только в текстовый файл.
    write_txt(sucfailwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
    sucfailwrite = '' # Обнуляем переменную.
    # Ошибка запишется в текстовый файл, но из-за ошибки получения авторизационных данных 
    # для доступа к БД программа на следующих шагах остановится из-за невозможности получения 
    # данных из БД. Но мы будем знать причину, прочитав ошибку в файле logmistakes.txt.

#-----------------------------------------------------------------------------------------------------------#

#############################################################################################################
#############################################################################################################
#-----------------------------------НАЧАЛО РАБОТЫ ГЛАВНОГО ЦИКЛА ПРОГРАММЫ----------------------------------#
#############################################################################################################
#############################################################################################################
   
#-------------------ПОЛУЧЕНИЕ ИЗ БД СПИСКА IP-АДРЕСОВ РРС С РАЗРЕШЕНИЕМ/ЗАПРЕТЕ МОНИТОРИНГА-----------------#

while True: # Начало бесконечного цикла.
            # Цикл в котором получаем из БД список IP-адресов с разрешением/запрете
            # мониторинга. Обрабатываем полученный список и формируем список IP-адресов
            # для которых разрешен мониторинг.
            # Ниже во вложенном цикле обрабатывается каждый IP-адрес из списка urls.
    connection = psycopg2.connect(dbn) # Подключение к БД с авторизационными данными dbn.
    cursor = connection.cursor() # Получение курсора для выполнения операций с БД.
    # Получение строки с перечнем IP-адресов из БД с разрешонным мониторингом.
    # '10.1.23.110 10.1.23.111 10.1.23.112 10.1.23.113'
    try: # Попытка.
        cursor.execute('SELECT ip_str from ubajax_Ubipstr') # Выполнение SQL-запроса.
        # Если urls_all = cursor.fetchone() получаем кортеж с первым (нулевым) элементом.
        # Результат: ('10.1.23.110 10.1.23.111 10.1.23.112 10.1.23.113',)
        urls_all = cursor.fetchone()[0] # Получение результата.
                                        # '10.1.23.110 10.1.23.111 10.1.23.112 10.1.23.113'
        #print(urls_all) # Для тестирования.
        # Получаем список IP-адресов с разрешенным мониторингом.
        urls = urls_all.split(' ')
        #print(urls) # Для тестирования.
        # В переменную sucfailwrite, записываем успешное действие - 
        # 'Список IP-адресов получен из БД.'
        sucfailwrite = 'Список IP-адресов получен из БД.'
        sucfail(dbn, 'Для всех', sucfailwrite, timewrite) # Запись успеха в БД.
        sucfailwrite = '' # Обнуляем переменную.
    except Exception: # Исключение.
        # В переменную sucfailwrite, записываем ошибку - 
        # 'Ошибка получения списка IP-адресов из БД.'
        sucfailwrite = 'Ошибка получения списка IP-адресов из БД.'
        sucfail(dbn, 'Для всех', sucfailwrite, timewrite, 'fail') # Запись ошибки в БД.
        write_txt(sucfailwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
        sucfailwrite = '' # Обнуляем переменную.
    #print(urls_all) # Для тестирования.
    cursor.close() # Закрытие курсора.
    connection.close() # Закрытие соединения.

#-----------------------------------------------------------------------------------------------------------#

#############################################################################################################
#---------------------------------------НАЧАЛО РАБОТЫ ЦИКЛА ПРОГРАММЫ---------------------------------------#
#############################################################################################################

    for url in urls: # Цикл для обработки одного адреса из списка IP-адресов.
        #print(url) # Для тестирования.
        timewrite = datetime.now()
        #print(timewrite) # Для тестирования. 
        # При старте программы flagupdate = 1, все данные считываются и записываются в БД. 
        # В конце главного цикла программы сравниваем timewrite с timewritestart,
        # если прошёл 1 час или более, timewritestart присваиваем текущее значение времени
        # timewritestart = timewrite и flagupdate = 1 , если прошло меньше часа
        # flagupdate = 0 и часть данных не получаем и не записываем в БД.     
         
#------------------------------------------------------------------------------------------------------------#

#---------------------ПОЛУЧЕНИЕ ИЗ БД ЛОГИНА И ПАРОЛЯ ДЛЯ ВХОДА В РРС (ДЛЯ ЛОКАЛЬНОГО url)-------------------#
#--------------МЫ В ЦИКЛЕ ПРОГРАММЫ В КОТОРОМ ОБРАБАТЫВАЕТСЯ ОДИН IP-АДРЕС, ПОЭТОМУ ДВА ОТСТУПА--------------#
         
        connection = psycopg2.connect(dbn)
        cursor = connection.cursor()
        # Получение логина и пароля для входа в РРС для одного IP-адреса (Применим ко всей РРЛ).
        # [('admin', 'admin')]
        # Для локального и для удалённого (в случае отсутствия доступа к локальному) в БД передаём url локального РРС.
        cursor.execute('SELECT ubntlogin, ubntpassword from ubajax_ubntmodeltest WHERE ipubntone=%s', (url,))
        logpas = cursor.fetchone() # ('admin', 'admin') Логин и пароль в одном кортеже.
        #print(logpas) Для тестирования.
        cursor.close()
        connection.close()

#--------------------------------------------ПОЛУЧЕНИЕ ЛОГИНА И ПАРОЛЯ---------------------------------------#        
         
        login = logpas[0]    # Логин для входа.
        password = logpas[1] # Пароль для входа.
         
#------------------------------------------------------------------------------------------------------------#

#----------ПОЛУЧЕНИЕ МАРКЕРА (ФЛАГА) rrsflag ИЗ БД ДЛЯ ОПРЕДЕЛЕНИЯ: ЭТОТ IP-АДРЕС AirFiber ИЛИ Alcoma--------#            

        # Получение флага для идентификации РРС. Если "0" - это AirFiber, Если "1" - это Alcoma.
        connection = psycopg2.connect(dbn)
        cursor = connection.cursor()         
        cursor.execute('SELECT rrsflag from ubajax_ubntmodeltest WHERE ipubntone=%s', (url,))
        # cursor.fetchone() # (1,) или (0,). 
        rrsflag = cursor.fetchone()[0] # 1 или 0.                 
        #print(rrsflag) # Для тестирования.
        cursor.close()
        connection.close()

#------------------------------------------------------------------------------------------------------------#        

#----------------------------------------------ПИНГУЕМ ЛОКАЛЬНЫЙ URL-----------------------------------------#
        
        pu = pingurl(url, 'l') # Вызов функции для осуществления ping.
        if pu == 1: # На пинг отозвался.
            # В переменную sucfailwrite, записываем успешное действие - 
            # 'На PING отозвался.'
            sucfailwrite = 'На PING отозвался.'
            sucfail(dbn, url, sucfailwrite, timewrite) # Запись успеха в БД.
            sucfailwrite = '' # Обнуляем переменную.
            markeriprem = False # Записывается в БД маркер того, что мотниторинг
                                # осуществляется со стороны локального РРС.
            purem = 0 # Для внесения в БД.
        elif pu == 0: # На пинг не отозвался.
            # В переменную sucfailwrite, записываем ошибку - 
            # 'Ошибка получения списка IP-адресов из БД.'
            sucfailwrite = f'На PING не отозвался {url}. \
                             Пытаемся зайти в РРЛ через IP-адрес удалённой РРС.'
            sucfail(dbn, url, sucfailwrite, timewrite, 'fail') # Запись ошибки в БД.
            write_txt(sucfailwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
            sucfailwrite = '' # Обнуляем переменную.
                        
#------------------------------------------------------------------------------------------------------------#

#---------------ЕСЛИ НЕ ОТОЗВАЛСЯ НА ПИНГ ЛОКАЛЬНЫЙ URL ПОЛУЧАЕМ ИЗ БД IP-АДРЕС УДАЛЁННОГО РРС---------------#

            urlremall = geturlrem(dbn, url) # Вызываем функцию geturlrem(dbn, url) для получения из БД urlrem.
            urlrem = urlremall[0] # IP-адрес удалённого РРС.
            #print(f'IP-адрес удалённого РРС {urlrem}') # Для тестирования.
            if urlremall[1] == 's': # Если flag == 's' (Успех).
                # В переменную sucfailwrite, записываем успешное действие - 
                # 'Удалённый IP-адрес получен из БД.'
                sucfail(dbn, url, urlremall[2], timewrite) # Запись успеха в БД.
            elif urlremall[1] == 'f': # Если flag == 'f' (Провал).
                # В переменную sucfailwrite, записываем ошибку - 
                # 'Ошибка получения удалённого IP-адреса из БД.'
                sucfail(dbn, url, urlremall[2], timewrite, 'fail') # Запись ошибки в БД.
                write_txt(urlremall[2], timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
                continue # Переход к следующему IP-адресу из списка.
            sucfailwrite = '' # Обнуляем переменную.
            
#------------------------------------------------------------------------------------------------------------#                 

#----------------------------------------ПИНГУЕМ УДАЛЁННЫЙ IP-АДРЕС------------------------------------------#
                               
            purem = pingurl(urlrem, 'l') # Вызов функции для осуществления ping.
            #print(purem) # Для тестирования.
            if purem == 1: # Если пингуется удалённый IP-адрес.
                # В переменную sucfailwrite, записываем успешное действие - 
                # 'На PING отозвался.'
                sucfailwrite = 'Удалённый РРС на PING отозвался.'
                sucfail(dbn, url, sucfailwrite, timewrite) # Запись успеха в БД.
                sucfailwrite = '' # Обнуляем переменную.
                url = urlrem # Описание этого действия ниже.
                markeriprem = True # Записывается в БД маркер того, что мотниторинг
                                   # осуществляется со стороны удалённого РРС. 
            elif purem == 0: # Если не пингуется удалённый IP-адрес, а значит и вся РРЛ.
                # В переменную sucfailwrite, записываем ошибку - 
                # 'Ошибка получения списка IP-адресов из БД.'
                sucfailwrite = 'Удалённый РРС на PING не отозвался. \
                                РРЛ не доступна для мониторинга. Переходим к следующей РРЛ.'
                sucfail(dbn, url, sucfailwrite, timewrite, 'fail') # Запись ошибки в БД.
                write_txt(f'{url}-->{sucfailwrite}', timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
                sucfailwrite = '' # Обнуляем переменную.
                continue # Переход к следующему IP-адресу из списка.
                         # (Локальная и удалённая РРС - не пингуется).

#------------------------------------------------------------------------------------------------------------#

#---------------------------------------------ВЫВОДЫ ПО ПИНГАМ-----------------------------------------------#
#-----Если purem равно 1 значит локальный IP-адрес не пингуется и мы работаем с РРЛ через удалённый РРС------#
#-------Присваиваем локальному url удалённый urlrem (url = urlrem) и проводим далее все операции с url-------#
#------------Иначе если purem не равно 1, то значит pu равно 1 (на пинг отозвался локальный url)-------------#
#----------------------------------и мы работаем с локальным url---------------------------------------------#
#------------------------------------------------------------------------------------------------------------#
        
#-------------------------------ПРОВЕРКА IP-АДРЕСА РРС. ЭТО AirFiber ИЛИ Alcoma------------------------------#
         
        if rrsflag == 0: # Если РРС AirFiber.           
            # Ниже код для РРС AirFiber.
            #print('Это РРС AirFiber') # Для тестирования.
            sucfailwrite = '' # Обнуляем переменную.

#------------------------------------------------------------------------------------------------------------#            

            # Формируем словарь с логином и паролем для входа в AirFiber.
            payload = {'username': login, 'password': password, 'login': 'Login'}

            req = ubreq(url, payload) # Устанавливаем http-сессию с РРС.
            #print(req) # Для тестирования.
            if req[1] == 'f': # Если установить http-сессию с РРС не удалось.
                # В переменную sucfailwrite, записываем ошибку req[2].                 
                sucfail(dbn, url, req[2], timewrite, 'fail') # Запись ошибки в БД.
                write_txt(req[2], timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
                reqs = ubreq(url, payload, 'https')# Устанавливаем https-сессию с РРС.
                if reqs[1] == 'f': # Если установить https-сессию с РРС не удалось.
                    # В переменную sucfailwrite, записываем ошибку reqs[2].                 
                    sucfail(dbn, url, req[2], timewrite, 'fail') # Запись ошибки в БД.
                    write_txt(reqs[2], timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
                    continue # Переход к следующему IP-адресу из списка, так как не удалось установить 
                             # http и https сессию с РРС.
                elif reqs[1] == 's': # Если удалось установить https-сессию с РРС.
                    # В переменную sucfailwrite, записываем успешное действие reqs[2].                 
                    sucfail(dbn, url, reqs[2], timewrite) # Запись успешного действия в БД.
                    
                    ##############################################
                    # ВЫЗОВ ФУНКЦИИ ДЛЯ ПОЛУЧЕНИЯ JSON ДЛЯ HTTPS #
                    ##############################################                    
                    sgetjson = ubjson(reqs[0], url, 'hhtps')
                    #print(sgetjson) # Для тестирования.
                    reqs[0].close() # Закрываем сессию.
                    if sgetjson[1] == 's': # Если получить JSON в https-сессии получилось.
                        # В переменную sucfailwrite, записываем успешное действие sgetjson[2].                 
                        sucfail(dbn, url, sgetjson[2], timewrite) # Запись успешного действия в БД.
                        getjson = sgetjson[0]
                    elif sgetjson[1] == 'f': # Если получить JSON в https-сессии не получилось.
                        # В переменную sucfailwrite, записываем ошибку sgetjson[2].                 
                        sucfail(dbn, url, sgetjson[2], timewrite, 'fail') # Запись ошибки в БД.
                        write_txt(sgetjson[2], timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
                        continue # Переход к следующему IP-адресу из списка.                        
            elif req[1] == 's': # Если установить http-сессию с РРС удалось.
                # В переменную sucfailwrite, записываем успешное действие req[2]. 
                sucfail(dbn, url, req[2], timewrite) # Запись успешного действия в БД.
                
                #############################################
                # ВЫЗОВ ФУНКЦИИ ДЛЯ ПОЛУЧЕНИЯ JSON ДЛЯ HTTP #
                #############################################
                sgetjson = ubjson(req[0], url)
                #print(sgetjson) # Для тестирования.
                req[0].close() # Закрываем сессию.
                if sgetjson[1] == 's': # Если получить JSON в http-сессии получилось.
                    # В переменную sucfailwrite, записываем успешное действие.                 
                    sucfail(dbn, url, sgetjson[2], timewrite) # Запись успешного действия в БД.
                    getjson = sgetjson[0]
                elif sgetjson[1] == 'f': # Если получить JSON в http-сессии не получилось.
                    # В переменную sucfailwrite, записываем ошибку sgetjson[2].                 
                    sucfail(dbn, url, sgetjson[2], timewrite, 'fail') # Запись ошибки в БД.
                    write_txt(sgetjson[2], timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
                    continue # Переход к следующему IP-адресу из списка.
                
            ##############################################
            # ВЫЗОВ ФУНКЦИИ ДЛЯ ПОЛУЧЕНИЯ ДАННЫХ ИЗ JSON #
            ##############################################
            fromjson = getdatajsonalways(url, getjson)
            if fromjson[1] == 's': # Если успех при получении данных из JSON.
                # В переменную sucfailwrite, записываем успешное действие fromjson[2].                 
                sucfail(dbn, url, fromjson[2], timewrite) # Запись успешного действия в БД.
                data = fromjson[0] # Получение списка с данными.
                # print(data) # Для тестирования.
                if data[1] == 'n/a': # ipubnttworemflag == data[1].
                    data[1] = geturlrem(dbn, url)[0] # ipubnttworem берём из БД.
                # Иначе остаётся data[1] (ipubnttworemflag) как есть.
                if flagupdate == 1: # Если пришло время обновлять данные.
                    #########################################################
                    # ВЫЗОВ ФУНКЦИИ ДЛЯ ПОЛУЧЕНИЯ ДАННЫХ detail_txt ИЗ JSON #
                    #########################################################
                    sdetail_txt = getdatajsononce(url, data[1], getjson) # Кортеж с данными (detail_txt, flag, sucfailwrite).
                    #print(sdetail_txt) # Для тестирования.
                    if sdetail_txt[1] == 's': # Если получить данные из JSON получилось.
                        # В переменную sucfailwrite, записываем успешное действие sdetail_txt[2].                 
                        sucfail(dbn, url, sdetail_txt[2], timewrite) # Запись успешного действия в БД.
                        detail_txt = sdetail_txt[0] # Строка с данными detail_txt.
                    elif sdetail_txt[1] == 'f': # Если получить данные из JSON не получилось.
                        # В переменную sucfailwrite, записываем ошибку sdetail_txt[2].                 
                        sucfail(dbn, url, sdetail_txt[2], timewrite, 'fail') # Запись ошибки в БД.
                        write_txt(sdetail_txt[2], timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
                        continue # Переход к следующему IP-адресу из списка.                    
                    
                    ###################################################
                    # ВЫЗОВ ФУНКЦИИ ДЛЯ ЗАПИСИ ДАННЫХ detail_txt В БД #
                    ###################################################
                    try: # Попытка.
                        writedetailtxttodb(dbn, detail_txt, url)
                        # В переменную sucfailwrite, записываем успешное действие.
                        sucfailwrite = 'Данные detail_txt успешно записаны в БД'
                        sucfail(dbn, url, sucfailwrite, timewrite) # Запись успешного действия в БД.
                        sucfailwrite = '' # Обнуляем переменную.
                    except Exception: # Исключение.
                        # В переменную sucfailwrite, записываем ошибку.
                        sucfailwrite = 'Ошибка при попытке записи данных detail_txt в БД'
                        sucfail(dbn, url, sucfailwrite, timewrite, 'fail') # Запись ошибки в БД.
                        write_txt(sucfailwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
                        sucfailwrite = '' # Обнуляем переменную.
                        continue # Переход к следующему IP-адресу из списка.
            elif fromjson[1] == 'f': # Если ошибка при получении данных из JSON.
                # В переменную sucfailwrite, записываем ошибку.                 
                sucfail(dbn, url, fromjson[2], timewrite, 'fail') # Запись ошибки в БД.
                write_txt(fromjson[2], timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
                continue # Переход к следующему IP-адресу из списка.
            
            #############################################################################
            # ВЫЗОВ ФУНКЦИИ ДЛЯ ФОРМИРОВАНИЯ КОРТЕЖА datanew ИЗ СПИСКА data И timewrite #
            #############################################################################    
            datanew = dotupledata(data, markeriprem, pu, purem, timewrite) # Создание кортежа из списка.
            #print(datanew) # Для тестирования.
            
            ################################################
            # ВЫЗОВ ФУНКЦИИ ДЛЯ ЗАПИСИ ДАННЫХ datanew В БД #
            ################################################
            try: # Попытка.
                writedatatodb(dbn, datanew) # Запись данных в БД.
                # В переменную sucfailwrite, записываем успешное действие.
                sucfailwrite = 'Данные datanew успешно записаны в БД'
                sucfail(dbn, url, sucfailwrite, timewrite) # Запись успешного действия в БД.
                sucfailwrite = '' # Обнуляем переменную.
            except Exception: # Исключение.
                # В переменную sucfailwrite, записываем ошибку.
                sucfailwrite = 'Ошибка при попытке записи данных datanew в БД'
                sucfail(dbn, url, sucfailwrite, timewrite, 'fail') # Запись ошибки в БД.
                write_txt(sucfailwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
                sucfailwrite = '' # Обнуляем переменную.
                continue # Переход к следующему IP-адресу из списка.            
                    
#------------------------------------------------------------------------------------------------------------#
            
#-------------------------------ПРОВЕРКА IP-АДРЕСА РРС. ЭТО AirFiber ИЛИ Alcoma------------------------------#
         
        elif rrsflag == 1: # Если РРС Alcoma.
            # Ниже код код для РРС Alcoma.
            #print('Это РРС Alcoma') # Для тестирования.
            sucfailwrite = '' # Обнуляем переменную.

#------------------------------------------------------------------------------------------------------------#
                    
#--------------------------ОТКРЫВАЕМ ТЕЛНЕТ-СЕССИЮ ТОЛЬКО С ЛОКАЛЬНЫМ IP-АДРЕСОМ-----------------------------#
#--------------------------------------ВВОДИМ ИМЯ ПОЛЬЗОВАТЕЛЯ И ПАРОЛЬ--------------------------------------#
#-------------------------------------ПОЛУЧАЕМ ИМЯ ЛОКАЛЬНОГО УСТРОЙСТВА-------------------------------------#

            try: # Попытка.
                tn = telnetlib.Telnet(url) # Окрытие Telnet-сессии.                
            except Exception: # Исключение.
                # В переменную sucfailwrite, записываем ошибку - 
                # 'Ошибка открытия Telnet-сессии с url.'
                sucfailwrite = f'Ошибка открытия Telnet-сессии с {url}.'
                sucfail(dbn, url, sucfailwrite, timewrite, 'fail') # Запись ошибки в БД.
                write_txt(sucfailwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
                sucfailwrite = '' # Обнуляем переменную.
                continue # Пропускаем эту итерацию цикла и переходим к следующему IP.           
        
            # ПРЕДУПРЕЖДЕНИЕ: Перед методом read_very_eager 
            # всегда надо ставить time.sleep(n).
            time.sleep(0.3) # Задержка времени.

#-----------------------------------ПОЛУЧЕНИЕ СТРОКИ С ДАННЫМИ (text) Login----------------------------------#

            # Получение данных Telnet-сессии.
            text = tn.read_very_eager().decode('utf-8')
            #print(text) # router login:

#------------------------------------------------------------------------------------------------------------#            

#--------------------------------------БЛОК ПРОВЕРКИ НА УСПЕХ ИЛИ ПРОВАЛ-------------------------------------#
#--------------------------------------------------ВВОД ЛОГИНА-----------------------------------------------#

            if text.find('login:') != -1:
                tn.write(to_bytes(login)) # Ввод логина (Логин: 1).
                #tn.write(b'1\n') # Ввод логина (Логин: 1).
                # В переменную sucfailwrite, записываем успешное действие - 
                # 'Telnet-сессия с url открыта.'
                sucfailwrite = 'Telnet-сессия открыта.'
                sucfail(dbn, url, sucfailwrite, timewrite) # Запись успеха в БД.
                sucfailwrite = '' # Обнуляем переменную.               
            else:
                # В переменную sucfailwrite, записываем провальное действие - 
                # 'Ошибка доступа к устройству с IP: url.'
                sucfailwrite = f'Ошибка доступа к устройству {url}'
                sucfail(dbn, url, sucfailwrite, timewrite, 'fail') # Запись ошибки в БД.
                write_txt(sucfailwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
                sucfailwrite = '' # Обнуляем переменную.
                tn.close() # Закрытие Телнет-сессии.
                continue # Пропускаем эту итерацию цикла и переходим к следующему IP.
                
            time.sleep(0.3) # Задержка времени.

#------------------------------------------------------------------------------------------------------------#

#----------------------------------ПОЛУЧЕНИЕ СТРОКИ С ДАННЫМИ (text) Password--------------------------------#
        
            # Получение данных Telnet-сессии.
            text = tn.read_very_eager().decode('utf-8')
            #print(text) # router Password:
            
#------------------------------------------------------------------------------------------------------------#            

#--------------------------------------БЛОК ПРОВЕРКИ НА УСПЕХ ИЛИ ПРОВАЛ-------------------------------------#
#--------------------------------------------------ВВОД ПАРОЛЯ-----------------------------------------------#
           
            if text.find('Password:') != -1:
                #print(password) # Для тестирования.
                tn.write(to_bytes(password)) # Ввод пароля (Пароль: 1).
                #tn.write(b'1\n') # Ввод пароля (Пароль: 1).
                # В переменную sucfailwrite, записываем успешное действие - 
                # 'Логин введён.'
                sucfailwrite = 'Логин введён.'
                #print(sucfailwrite) # Для тестирования.
                sucfail(dbn, url, sucfailwrite, timewrite) # Запись успеха в БД.
                sucfailwrite = '' # Обнуляем переменную.
            else:
                # В переменную sucfailwrite, записываем провальное действие - 
                # 'На этапе ввода логина произошла ошибка.'
                sucfailwrite = f'На этапе ввода логина произошла ошибка для {url}'
                sucfail(dbn, url, sucfailwrite, timewrite, 'fail') # Запись ошибки в БД.
                write_txt(sucfailwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
                sucfailwrite = '' # Обнуляем переменную.
                #print(sucfailwrite) # Для тестирования.
                tn.close() # Закрытие Телнет-сессии.
                continue # Пропускаем эту итерацию цикла и переходим к следующему IP.
                            
            time.sleep(1.5) # Задержка времени.

#------------------------------------------------------------------------------------------------------------#

#----------------------ПОЛУЧЕНИЕ СТРОКИ С ДАННЫМИ (text) ИЗ МЕНЮ "General Information"-----------------------#
        
            # Получение данных Telnet-сессии.
            text = tn.read_very_eager().decode('utf-8')

#------------------------------------------------------------------------------------------------------------#            

#----------------------------------------------БЛОК ТЕСТИРОВАНИЯ---------------------------------------------#            
            #print('*******************************************************************************')
            #print('ЭТО --> General Information') # Для тестирования.
            #print(text) # Для тестирования.
            #print()
#------------------------------------------------------------------------------------------------------------#

#--------------------------------------БЛОК ПРОВЕРКИ НА УСПЕХ ИЛИ ПРОВАЛ-------------------------------------#
#-----------------------------------------ПЕРЕХОД В МЕНЮ "Main Menu"-----------------------------------------#            
            
            if text.find('General Information') != -1:
                tn.write(to_bytes('m')) # Ввод 'm' для входа в "Main Menu".
                #tn.write(b'm\n') # Ввод 'm' для входа в "Main Menu".
                # В переменную sucfailwrite, записываем успешное действие - 
                # 'Авторизация прошла успешно.'
                sucfailwrite = 'Пароль введён. Авторизация прошла успешно, открыто окно "General Information".'
                sucfail(dbn, url, sucfailwrite, timewrite) # Запись успеха в БД.
                sucfailwrite = '' # Обнуляем переменную.
            else:
                # В переменную sucfailwrite, записываем провальное действие - 
                # 'Авторизация не прошла.'
                sucfailwrite = f'Авторизация не прошла для {url}'
                sucfail(dbn, url, sucfailwrite, timewrite, 'fail') # Запись ошибки в БД.
                write_txt(sucfailwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
                sucfailwrite = '' # Обнуляем переменную.
                tn.close() # Закрытие Телнет-сессии.
                continue # Пропускаем эту итерацию цикла и переходим к следующему IP.

            time.sleep(1.0) # Задержка времени.

#------------------------------------------------------------------------------------------------------------#            

#----------------------------ПОЛУЧЕНИЕ СТРОКИ С ДАННЫМИ (text) ИЗ МЕНЮ "Main Menu"---------------------------#
        
            # Получение данных Telnet-сессии.
            text = tn.read_very_eager().decode('utf-8')

#------------------------------------------------------------------------------------------------------------#            

#----------------------------------------------БЛОК ТЕСТИРОВАНИЯ---------------------------------------------#            
            #print('*******************************************************************************')
            #print('ЭТО --> Main Menu') # Для тестирования.
            #print(text) # Для тестирования.
            #print()
#------------------------------------------------------------------------------------------------------------#

#--------------------------------------БЛОК ПРОВЕРКИ НА УСПЕХ ИЛИ ПРОВАЛ-------------------------------------#
#------------------------------------------ПЕРЕХОД В МЕНЮ "Analysis"-----------------------------------------#
           
            if text.find('Main Menu') != -1:
                tn.write(to_bytes('d')) # Ввод 'd' для входа в "Analysis".
                #tn.write(b'd\n') # Ввод 'd' для входа в "Analysis".
                # В переменную sucfailwrite, записываем успешное действие - 
                # 'Открыто окно "Main Menu".'
                sucfailwrite = 'Открыто окно "Main Menu".'
                sucfail(dbn, url, sucfailwrite, timewrite) # Запись успеха в БД.
                sucfailwrite = '' # Обнуляем переменную.
            else:
                # В переменную sucfailwrite, записываем провальное действие - 
                # 'Произошла ошибка при входе в "Main Menu".'
                sucfailwrite = f'Произошла ошибка при входе в "Main Menu" для {url}'
                sucfail(dbn, url, sucfailwrite, timewrite, 'fail') # Запись ошибки в БД.
                write_txt(sucfailwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
                tn.close() # Закрытие Телнет-сессии.
                continue # Пропускаем эту итерацию цикла и переходим к следующему IP.

            time.sleep(1.0) # Задержка времени.

#------------------------------------------------------------------------------------------------------------#

#-----------------------------ПОЛУЧЕНИЕ СТРОКИ С ДАННЫМИ (text) ИЗ МЕНЮ "Analysis"---------------------------#
            
            # Получение данных Telnet-сессии.
            text = tn.read_very_eager().decode('utf-8')

#------------------------------------------------------------------------------------------------------------#            

#----------------------------------------------БЛОК ТЕСТИРОВАНИЯ---------------------------------------------#            
            #print('*******************************************************************************')
            #print('ЭТО --> Analysis') # Для тестирования.
            #print(text) # Для тестирования.
            #print()
#------------------------------------------------------------------------------------------------------------#

#--------------------------------------БЛОК ПРОВЕРКИ НА УСПЕХ ИЛИ ПРОВАЛ-------------------------------------#
#-------------------------------------ПЕРЕХОД В МЕНЮ "Status Information"------------------------------------#
            
            if text.find('Analysis') != -1:
                tn.write(to_bytes('a')) # Ввод 'a' для входа в "Status Information".
                #tn.write(b'a\n') # Ввод 'a' для входа в "Status Information".
                # В переменную sucfailwrite, записываем успешное действие - 
                # 'Открыто окно "Analysis".'
                sucfailwrite = 'Открыто окно "Analysis".'
                sucfail(dbn, url, sucfailwrite, timewrite) # Запись успеха в БД.
                sucfailwrite = '' # Обнуляем переменную.
            else:
                # В переменную sucfailwrite, записываем провальное действие - 
                # 'Произошла ошибка при входе в "Analysis".'
                sucfailwrite = f'Произошла ошибка при входе в "Analysis" для {url}'
                sucfail(dbn, url, sucfailwrite, timewrite, 'fail') # Запись ошибки в БД.
                write_txt(sucfailwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
                tn.close() # Закрытие Телнет-сессии.
                continue # Пропускаем эту итерацию цикла и переходим к следующему IP.

            time.sleep(1.0) # Задержка времени.

#------------------------------------------------------------------------------------------------------------#

#-------------------------ПОЛУЧЕНИЕ СТРОКИ С ДАННЫМИ (text) ИЗ МЕНЮ "Status Information"---------------------#
            
            # Получение данных Telnet-сессии.
            text = tn.read_very_eager().decode('utf-8')
            #########################################################
            # Здесь text содержит всю необходимую информацию об РРЛ #
            #########################################################
            
#------------------------------------------------------------------------------------------------------------#
            
#----------------------------------------------БЛОК ТЕСТИРОВАНИЯ---------------------------------------------#
            #print('*******************************************************************************')
            #print('ЭТО --> Status Information') # Для тестирования.
            #print(text) # Для тестирования.
            #print('*******************************************************************************')
#------------------------------------------------------------------------------------------------------------#

#--------------------------------------БЛОК ПРОВЕРКИ НА УСПЕХ ИЛИ ПРОВАЛ-------------------------------------#
            
            if text.find('Status Information') != -1:
                # В переменную sucfailwrite, записываем успешное действие - 
                # 'Открыто окно "Status Information".'
                sucfailwrite = 'Открыто окно "Status Information".'
                sucfail(dbn, url, sucfailwrite, timewrite) # Запись успеха в БД.
                sucfailwrite = '' # Обнуляем переменную.
            else:
                # В переменную sucfailwrite, записываем провальное действие - 
                # 'Произошла ошибка при входе в "Status Information".'
                sucfailwrite = f'Произошла ошибка при входе в "Status Information" для {url}'
                sucfail(dbn, url, sucfailwrite, timewrite, 'fail') # Запись ошибки в БД.
                write_txt(sucfailwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
                tn.close() # Закрытие Телнет-сессии.
                continue # Пропускаем эту итерацию цикла и переходим к следующему IP.

#------------------------------------------------------------------------------------------------------------#            
            
            ################################################################
            # ВЫЗОВ ФУНКЦИИ ДЛЯ ПОЛУЧЕНИЯ ДАННЫХ data ИЗ text С РРС ALCOMA #
            ################################################################
            sdata = getdatalcalways(url, text, markeriprem, pu, purem, timewrite) # Кортеж с данными (data, flag, sucfailwrite).
            #print(sdata) # Для тестирования.
            if sdata[1] == 's': # Если получить данные из text получилось.
                # В переменную sucfailwrite, записываем успешное действие sdata[2].                 
                sucfail(dbn, url, sdata[2], timewrite) # Запись успешного действия в БД.
                data = sdata[0] # Кортеж с данными data.
            elif sdata[1] == 'f': # Если получить данные из text не получилось.
                # В переменную sucfailwrite, записываем ошибку sdata[2].                 
                sucfail(dbn, url, sdata[2], timewrite, 'fail') # Запись ошибки в БД.
                write_txt(sdata[2], timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
                continue # Переход к следующему IP-адресу из списка.
            
            #############################################
            # ВЫЗОВ ФУНКЦИИ ДЛЯ ЗАПИСИ ДАННЫХ data В БД #
            #############################################
            try: # Попытка.
                writedatatodb(dbn, data) # Вызов функции для записи в БД.
                # В переменную sucfailwrite, записываем успешное действие.
                sucfailwrite = 'Данные data успешно записаны в БД'
                sucfail(dbn, url, sucfailwrite, timewrite) # Запись успешного действия в БД.
                sucfailwrite = '' # Обнуляем переменную.
            except Exception: # Исключение.
                # В переменную sucfailwrite, записываем ошибку.
                sucfailwrite = 'Ошибка при попытке записи данных data в БД'
                sucfail(dbn, url, sucfailwrite, timewrite, 'fail') # Запись ошибки в БД.
                write_txt(sucfailwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
                sucfailwrite = '' # Обнуляем переменную.
                continue # Переход к следующему IP-адресу из списка.
            
            if flagupdate == 1: # Если пришло время обновлять данные.
                ######################################################################
                # ВЫЗОВ ФУНКЦИИ ДЛЯ ПОЛУЧЕНИЯ ДАННЫХ detail_txt ИЗ text С РРС ALCOMA #
                ######################################################################
                sdetail_txt = getdatalcononce(url, sdata[0][1], text, timewrite) # Кортеж с данными (detail_txt, flag, sucfailwrite).
                #print(sdetail_txt) # Для тестирования.
                if sdetail_txt[1] == 's': # Если получить данные из text получилось.
                    # В переменную sucfailwrite, записываем успешное действие sdetail_txt[2].                 
                    sucfail(dbn, url, sdetail_txt[2], timewrite) # Запись успешного действия в БД.
                    detail_txt = sdetail_txt[0] # Кортеж с данными detail_txt.
                elif sdetail_txt[1] == 'f': # Если получить данные из text не получилось.
                    # В переменную sucfailwrite, записываем ошибку sdetail_txt[2].                 
                    sucfail(dbn, url, sdetail_txt[2], timewrite, 'fail') # Запись ошибки в БД.
                    write_txt(sdetail_txt[2], timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
                    continue # Переход к следующему IP-адресу из списка.                           
                
                ###################################################
                # ВЫЗОВ ФУНКЦИИ ДЛЯ ЗАПИСИ ДАННЫХ detail_txt В БД #
                ###################################################
                try: # Попытка.
                    writedetailtxttodb(dbn, detail_txt, url) # Вызов функции для записи в БД.
                    # В переменную sucfailwrite, записываем успешное действие.
                    sucfailwrite = 'Данные detail_txt успешно записаны в БД'
                    sucfail(dbn, url, sucfailwrite, timewrite) # Запись успешного действия в БД.
                    sucfailwrite = '' # Обнуляем переменную.
                except Exception: # Исключение.
                    # В переменную sucfailwrite, записываем ошибку.
                    sucfailwrite = 'Ошибка при попытке записи данных detail_txt в БД'
                    sucfail(dbn, url, sucfailwrite, timewrite, 'fail') # Запись ошибки в БД.
                    write_txt(sucfailwrite, timewrite) # Вызов функции для записи ошибки в txt-файл logmistakes.txt.
                    sucfailwrite = '' # Обнуляем переменную.
                    continue # Переход к следующему IP-адресу из списка.

#------------------------------------------------------------------------------------------------------------#          
                    
#---------------------------------------КОНЕЦ РАБОТЫ ЦИКЛА ПРОГРАММЫ-----------------------------------------#
         
#-------------------------ПРОВЕРКА ВРЕМЕНИ РАБОТЫ ПРОГРАММЫ (ПРОШЁЛ ОДИН ЧАС ИЛИ НЕТ)------------------------#                      
        
    tt = timewritestart + timedelta(hours=1)
    if tt <= timewrite: # Если прошёл один час.
        flagupdate = 1
        timewritestart = datetime.now()
        # Обновляем данные со всех устройств. После обновления всех IP из списка flagupdate = 0.
    else:
        flagupdate = 0
        
#------------------------------------------------------------------------------------------------------------#

#------------------------------------КОНЕЦ РАБОТЫ ГЛАВНОГО ЦИКЛА ПРОГРАММЫ-----------------------------------#

#----------------------------------------КОНЕЦ ПРОГРАММЫ МОНИТОРИНГА-----------------------------------------#




